
elenas@e56:~/WORK/ulam/repo/ULAM$ !gdb
gdb ./bin/culamtest
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bin/culamtest...done.
(gdb) r src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test
Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test
INVALID: GOT[
./Q.ulam:3:24: ERROR: Constant value expression for: a, is not a constant.
./System.ulam:2:7: ERROR: 1 Nodes with erroneous types detected after type labeling class: System.
./System.ulam:2:7: ERROR: 2 Nodes with unresolved types detected after type labeling class: System.
Unrecoverable Program Type Label FAILURE.
]
BUT EXPECTED[
Exit status: 3
Ue_P { Bool(1) b(true);  Int(32) test() {  System s;  Q(3u,3) w;  s ( 3u )print . b true = s ( b )assert . 3u cast return } }
Uq_Q(Unsigned(32) s = NONREADYCONST, Int(32) b = NONREADYCONST) { typedef Unsigned(UNKNOWN) Foo;  Unsigned(UNKNOWN) f(notready);  <NOMAIN> }
Uq_V(Int(32) a) { Unsigned(UNKNOWN) vfoo(notready);  <NOMAIN> }
Uq_System { <NOMAIN> }
]
[Inferior 1 (process 21632) exited with code 01]
(gdb) b MFM::Resolver::constantFoldNonreadyClassArgs
Breakpoint 1 at 0x55bc6f: file Resolver.cpp, line 281.
(gdb) r
Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x827b00,
    stubcsym=0x8259a0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) p m_state.getCompileThisIdx()
$1 = 40
(gdb) n
282	    UTI context = getContextForPendingArgs();
(gdb)
283	    if(m_state.isAClass(context))
(gdb)
285		SymbolClass * contextSym = NULL;
(gdb)
286		AssertBool isDefined = m_state.alreadyDefinedSymbolClass(context, contextSym);
(gdb)
287		assert(isDefined);
(gdb)
288		NodeBlockClass * contextclassblock = contextSym->getClassBlockNode();
(gdb)
289		m_state.pushClassContext(context, contextclassblock, contextclassblock, false, NULL);
(gdb)
298	    m_state.m_pendingArgStubContext = m_classUTI; //set for folding surgery
(gdb)
300	    bool defaultval = false;
(gdb)
301	    bool pushedtemplate = false;
(gdb)
302	    assert(stubcsym);
(gdb)
303	    NodeBlockClass * stubclassblock = stubcsym->getClassBlockNode();
(gdb)
304	    assert(stubclassblock);
(gdb)
306
(gdb)
307	    std::vector<NodeConstantDef *> leftCArgs;
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
313		  {
(gdb)
315		    //OMG! if this was a default value for class arg, t3891,
(gdb)
320			assert(stubcsym);
(gdb) n
321			SymbolClassNameTemplate * templateparent = stubcsym->getParentClassTemplate();
(gdb)
322			assert(templateparent);
(gdb)
324			//m_state.pushClassContext(templateparent->getUlamTypeIdx(), templateclassblock, templateclassblock, false, NULL);
(gdb)
326			m_state.pushClassContext(m_classUTI, stubclassblock, stubclassblock, false, NULL);
(gdb)
327			pushedtemplate = true;
(gdb)
333		      {
(gdb)
335			*vit = NULL;
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
`/home/elenas/WORK/ulam/repo/ULAM/bin/culamtest' has changed; re-reading symbols.

    Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x827b00,
    stubcsym=0x8259a0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) n
282	    UTI context = getContextForPendingArgs();
(gdb)
283	    if(m_state.isAClass(context))
(gdb)
285		SymbolClass * contextSym = NULL;
(gdb)
286		AssertBool isDefined = m_state.alreadyDefinedSymbolClass(context, contextSym);
(gdb)
287		assert(isDefined);
(gdb)
288		NodeBlockClass * contextclassblock = contextSym->getClassBlockNode();
(gdb)
289		m_state.pushClassContext(context, contextclassblock, contextclassblock, false, NULL);
(gdb)
298	    m_state.m_pendingArgStubContext = m_classUTI; //set for folding surgery
(gdb)
300	    bool defaultval = false;
(gdb)
301	    bool pushedtemplate = false;
(gdb)
302	    assert(stubcsym);
(gdb)
303	    NodeBlockClass * stubclassblock = stubcsym->getClassBlockNode();
(gdb)
304	    assert(stubclassblock);
(gdb)
305	    Locator saveStubLoc = stubclassblock->getNodeLocation();
(gdb)
307	    std::vector<NodeConstantDef *> leftCArgs;
(gdb)
308	    std::vector<NodeConstantDef *>::iterator vit = m_nonreadyClassArgSubtrees.begin();
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
311		NodeConstantDef * ceNode = *vit;
(gdb)
312		if(ceNode)
(gdb)
314		    defaultval = ceNode->hasDefaultSymbolValue();
(gdb)
318		    if(defaultval && !pushedtemplate)
(gdb)
320			assert(stubcsym);
(gdb)
321			SymbolClassNameTemplate * templateparent = stubcsym->getParentClassTemplate();
(gdb)
322			assert(templateparent);
(gdb)
323			NodeBlockClass * templateclassblock = templateparent->getClassBlockNode();
(gdb)
325			stubclassblock->setNodeLocation(templateclassblock->getNodeLocation());
(gdb)
326			m_state.pushClassContext(m_classUTI, stubclassblock, stubclassblock, false, NULL);
(gdb)
327			pushedtemplate = true;
(gdb)
329		    assert(defaultval == pushedtemplate); //once a default, always a default
(gdb)
331		    UTI uti = ceNode->checkAndLabelType();
(gdb)
332		    if(m_state.okUTItoContinue(uti)) //i.e. ready
(gdb)
338		      leftCArgs.push_back(ceNode);
(gdb)
340		vit++;
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
311		NodeConstantDef * ceNode = *vit;
(gdb)
312		if(ceNode)
(gdb)
314		    defaultval = ceNode->hasDefaultSymbolValue();
(gdb)
318		    if(defaultval && !pushedtemplate)
(gdb)
329		    assert(defaultval == pushedtemplate); //once a default, always a default
(gdb)
331		    UTI uti = ceNode->checkAndLabelType();
(gdb) s
MFM::NodeConstantDef::checkAndLabelType (this=0x828400)
    at NodeConstantDef.cpp:153
153	    UTI it = Nouti; //expression type
(gdb) n
156	    if(m_constSymbol == NULL)
(gdb)
160	    if(!m_constSymbol)
(gdb)
166	    UTI suti = m_constSymbol->getUlamTypeIdx();
(gdb)
167	    UTI cuti = m_state.getCompileThisIdx();
(gdb)
170	    if(m_nodeTypeDesc)
(gdb)
172		UTI duti = m_nodeTypeDesc->checkAndLabelType(); //clobbers any expr it
(gdb)
173		if(m_state.okUTItoContinue(duti) && (suti != duti))
(gdb)
193	    if(!m_state.okUTItoContinue(suti) || !m_state.isComplete(suti))
(gdb)
209	    ULAMTYPE etyp = m_state.getUlamTypeByIndex(suti)->getUlamTypeEnum();
(gdb)
210	    if(etyp == Void)
(gdb)
223	    if(m_nodeExpr)
(gdb)
225		it = m_nodeExpr->checkAndLabelType();
(gdb) s
MFM::NodeSquareBracket::checkAndLabelType (this=0x828460)
    at NodeSquareBracket.cpp:74
74	    assert(m_nodeLeft);
(gdb) n
75	    u32 errorCount = 0;
(gdb)
76	    u32 hazyCount = 0;
(gdb)
77	    UTI newType = Nav; //init
(gdb)
78	    UTI idxuti = Nav;
(gdb)
80	    UTI leftType = m_nodeLeft->checkAndLabelType();
(gdb) s
MFM::NodeIdent::checkAndLabelType (this=0x8284b0) at NodeIdent.cpp:136
136	    UTI it = Nouti;  //init (was Nav)
(gdb) n
137	    u32 errCnt = 0;
(gdb)
139	    setupBlockNo(); //in case zero
(gdb)
143	    if(m_varSymbol == NULL)
(gdb)
145		UTI cuti = m_state.getCompileThisIdx(); //for error messages
(gdb)
146		NodeBlock * currBlock = getBlock();
(gdb)
147		if(m_state.useMemberBlock())
(gdb) p *currBlock
$2 = {<MFM::NodeStatements> = {<MFM::Node> = {
      _vptr.Node = 0x56cc10 <vtable for MFM::NodeBlockClass+16>,
      m_state = @0x7fffffffdc50, m_utype = 40,
      m_storeIntoAble = MFM::TBOOL_FALSE, m_referenceAble = MFM::TBOOL_FALSE,
      m_loc = {m_pathIdx = 259, m_fullPathIdx = 260, m_lineNo = 3,
        m_byteNo = 7}, m_parentNo = 0, m_no = 36}, m_node = 0x0,
    m_nodeNext = 0x0}, m_ST = {<MFM::SymbolTable> = {
      _vptr.SymbolTable = 0x582390 <vtable for MFM::SymbolTableOfVariables+16>, m_idToSymbolPtr = std::map with 2 elements = {[270] = 0x825e30,
        [271] = 0x827b90}, m_state = @0x7fffffffdc50}, <No data fields>},
  m_prevBlockNode = 0x81bd90}
(gdb) n
153		  m_state.pushCurrentBlockAndDontUseMemberBlock(currBlock);
(gdb)
155		Symbol * asymptr = NULL;
(gdb)
156		bool hazyKin = false;
(gdb)
158		if(m_state.alreadyDefinedSymbol(m_token.m_dataindex, asymptr, hazyKin))
(gdb) s
MFM::CompilerState::alreadyDefinedSymbol (this=0x7fffffffdc50, dataindex=272,
    symptr=@0x7fffffffcd20: 0x0, hasHazyKin=@0x7fffffffccbd: false)
    at CompilerState.cpp:2414
2414	    bool brtn = false;
(gdb) n
2415	    assert(!hasHazyKin);
(gdb)
2419	    NodeBlock * blockNode = getCurrentBlock();
(gdb)
2422	    if(useMemberBlock())
(gdb)
2425	    while(!brtn && blockNode)
(gdb)
2427		brtn = blockNode->isIdInScope(dataindex,symptr); //check ST
(gdb)
2430		hasHazyKin |= checkHasHazyKin(blockNode);
(gdb)
2431		blockNode = blockNode->getPreviousBlockPointer(); //traverse the chain, including templates (not ancestors)
(gdb)
2425	    while(!brtn && blockNode)
(gdb)
2427		brtn = blockNode->isIdInScope(dataindex,symptr); //check ST
(gdb)
2430		hasHazyKin |= checkHasHazyKin(blockNode);
(gdb)
2431		blockNode = blockNode->getPreviousBlockPointer(); //traverse the chain, including templates (not ancestors)
(gdb)
2425	    while(!brtn && blockNode)
(gdb)
2436	    if(!brtn)
(gdb)
2437	      brtn = isDataMemberIdInClassScope(dataindex, symptr, hasHazyKin);
(gdb) s
MFM::CompilerState::isDataMemberIdInClassScope (this=0x7fffffffdc50,
    dataindex=272, symptr=@0x7fffffffcd20: 0x0,
    hasHazyKin=@0x7fffffffccbd: true) at CompilerState.cpp:2446
2446	    bool brtn = false;
(gdb) n
2451	    NodeBlockContext * cblock = getContextBlock();
(gdb)
2454	    if(useMemberBlock())
(gdb)
2457	    while(!brtn && cblock)
(gdb)
2459		brtn = cblock->isIdInScope(dataindex,symptr); //returns symbol
(gdb)
2460		hasHazyKin |= checkHasHazyKin(cblock); //self is stub
(gdb)
2461		cblock = cblock->isAClassBlock() ? ((NodeBlockClass *) cblock)->getSuperBlockPointer() : NULL; //inheritance chain
(gdb)
2457	    while(!brtn && cblock)
(gdb)
2459		brtn = cblock->isIdInScope(dataindex,symptr); //returns symbol
(gdb)
2460		hasHazyKin |= checkHasHazyKin(cblock); //self is stub
(gdb)
2461		cblock = cblock->isAClassBlock() ? ((NodeBlockClass *) cblock)->getSuperBlockPointer() : NULL; //inheritance chain
(gdb)
2457	    while(!brtn && cblock)
(gdb)
2465	    if(!brtn)
(gdb)
2466	      brtn = isIdInLocalFileScope(dataindex, symptr); //local constant or typedef
(gdb) s
MFM::CompilerState::isIdInLocalFileScope (this=0x7fffffffdc50, id=272,
    symptr=@0x7fffffffcd20: 0x0) at CompilerState.cpp:2473
2473	    bool brtn = false;
(gdb) n
2477	    NodeBlockContext * cblock = getContextBlock();
(gdb)
2480	    if(useMemberBlock())
(gdb)
2483	    Locator cloc;
(gdb)
2484	    if(cblock)
(gdb)
2485	      cloc = cblock->getNodeLocation(); //to check local scope
(gdb)
2487	    NodeBlockLocals * locals = getLocalScopeBlock(cloc);
(gdb) p cloc
$3 = {m_pathIdx = 259, m_fullPathIdx = 260, m_lineNo = 3, m_byteNo = 7}
(gdb) p m_state.getUlamTypeNameByIndex(259)
No symbol "m_state" in current context.
(gdb) p getUlamTypeNameByIndex(259)
culamtest: CompilerState.cpp:897: const string MFM::CompilerState::getUlamTypeNameByIndex(MFM::u16): Assertion `isDef' failed.

Program received signal SIGABRT, Aborted.
0x00007ffff7531c37 in __GI_raise (sig=sig@entry=6)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
56	../nptl/sysdeps/unix/sysv/linux/raise.c: No such file or directory.
The program being debugged was signaled while in a function called from GDB.
GDB remains in the frame where the signal was received.
To change this behavior use "set unwindonsignal on".
Evaluation of the expression containing the function
(MFM::CompilerState::getUlamTypeNameByIndex(unsigned short)) will be abandoned.
When the function is done executing, GDB will silently stop.
(gdb) up
#1  0x00007ffff7535028 in __GI_abort () at abort.c:89
89	abort.c: No such file or directory.
(gdb)
#2  0x00007ffff752abf6 in __assert_fail_base (
    fmt=0x7ffff767b3b8 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n",
    assertion=assertion@entry=0x56667a "isDef",
    file=file@entry=0x5665c6 "CompilerState.cpp", line=line@entry=897,
    function=function@entry=0x567fe0 <MFM::CompilerState::getUlamTypeNameByIndex(unsigned short)::__PRETTY_FUNCTION__> "const string MFM::CompilerState::getUlamTypeNameByIndex(MFM::u16)") at assert.c:92
92	assert.c: No such file or directory.
(gdb)
#3  0x00007ffff752aca2 in __GI___assert_fail (assertion=0x56667a "isDef",
    file=0x5665c6 "CompilerState.cpp", line=897,
    function=0x567fe0 <MFM::CompilerState::getUlamTypeNameByIndex(unsigned short)::__PRETTY_FUNCTION__> "const string MFM::CompilerState::getUlamTypeNameByIndex(MFM::u16)") at assert.c:101
101	in assert.c
(gdb)
#4  0x000000000041071b in MFM::CompilerState::getUlamTypeNameByIndex (
    this=0x7fffffffdc50, uti=259) at CompilerState.cpp:897
897	    assert(isDef);
(gdb)
#5  <function called from gdb>
(gdb)
#6  MFM::CompilerState::isIdInLocalFileScope (this=0x7fffffffdc50, id=272,
    symptr=@0x7fffffffcd20: 0x0) at CompilerState.cpp:2487
2487	    NodeBlockLocals * locals = getLocalScopeBlock(cloc);
(gdb) p m_state.m_pool.getDataAsString(259)
No symbol "m_state" in current context.
(gdb) p m_pool.getDataAsString(259)
$4 = "Q.ulam"
(gdb) n

Program terminated with signal SIGABRT, Aborted.
The program no longer exists.
(gdb) r
Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x827b00,
    stubcsym=0x8259a0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) n
282	    UTI context = getContextForPendingArgs();
(gdb)
283	    if(m_state.isAClass(context))
(gdb)
285		SymbolClass * contextSym = NULL;
(gdb)
286		AssertBool isDefined = m_state.alreadyDefinedSymbolClass(context, contextSym);
(gdb)
287		assert(isDefined);
(gdb)
288		NodeBlockClass * contextclassblock = contextSym->getClassBlockNode();
(gdb)
289		m_state.pushClassContext(context, contextclassblock, contextclassblock, false, NULL);
(gdb)
298	    m_state.m_pendingArgStubContext = m_classUTI; //set for folding surgery
(gdb)
300	    bool defaultval = false;
(gdb)
301	    bool pushedtemplate = false;
(gdb)
302	    assert(stubcsym);
(gdb)
303	    NodeBlockClass * stubclassblock = stubcsym->getClassBlockNode();
(gdb)
304	    assert(stubclassblock);
(gdb)
305	    Locator saveStubLoc = stubclassblock->getNodeLocation();
(gdb)
307	    std::vector<NodeConstantDef *> leftCArgs;
(gdb)
308	    std::vector<NodeConstantDef *>::iterator vit = m_nonreadyClassArgSubtrees.begin();
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
311		NodeConstantDef * ceNode = *vit;
(gdb)
312		if(ceNode)
(gdb)
314		    defaultval = ceNode->hasDefaultSymbolValue();
(gdb)
318		    if(defaultval && !pushedtemplate)
(gdb)
320			assert(stubcsym);
(gdb)
321			SymbolClassNameTemplate * templateparent = stubcsym->getParentClassTemplate();
(gdb)
322			assert(templateparent);
(gdb)
323			NodeBlockClass * templateclassblock = templateparent->getClassBlockNode();
(gdb)
325			stubclassblock->setNodeLocation(templateclassblock->getNodeLocation());
(gdb)
326			m_state.pushClassContext(m_classUTI, stubclassblock, stubclassblock, false, NULL);
(gdb)
327			pushedtemplate = true;
(gdb)
329		    assert(defaultval == pushedtemplate); //once a default, always a default
(gdb)
331		    UTI uti = ceNode->checkAndLabelType();
(gdb)
332		    if(m_state.okUTItoContinue(uti)) //i.e. ready
(gdb)
338		      leftCArgs.push_back(ceNode);
(gdb)
340		vit++;
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
311		NodeConstantDef * ceNode = *vit;
(gdb)
312		if(ceNode)
(gdb)
314		    defaultval = ceNode->hasDefaultSymbolValue();
(gdb)
318		    if(defaultval && !pushedtemplate)
(gdb)
329		    assert(defaultval == pushedtemplate); //once a default, always a default
(gdb)
331		    UTI uti = ceNode->checkAndLabelType();
(gdb) s
MFM::NodeConstantDef::checkAndLabelType (this=0x828400)
    at NodeConstantDef.cpp:153
153	    UTI it = Nouti; //expression type
(gdb) n
156	    if(m_constSymbol == NULL)
(gdb)
160	    if(!m_constSymbol)
(gdb)
166	    UTI suti = m_constSymbol->getUlamTypeIdx();
(gdb)
167	    UTI cuti = m_state.getCompileThisIdx();
(gdb)
170	    if(m_nodeTypeDesc)
(gdb)
172		UTI duti = m_nodeTypeDesc->checkAndLabelType(); //clobbers any expr it
(gdb)
173		if(m_state.okUTItoContinue(duti) && (suti != duti))
(gdb)
193	    if(!m_state.okUTItoContinue(suti) || !m_state.isComplete(suti))
(gdb)
209	    ULAMTYPE etyp = m_state.getUlamTypeByIndex(suti)->getUlamTypeEnum();
(gdb)
210	    if(etyp == Void)
(gdb)
223	    if(m_nodeExpr)
(gdb)
225		it = m_nodeExpr->checkAndLabelType();
(gdb) s
MFM::NodeSquareBracket::checkAndLabelType (this=0x828460)
    at NodeSquareBracket.cpp:74
74	    assert(m_nodeLeft);
(gdb) n
75	    u32 errorCount = 0;
(gdb)
76	    u32 hazyCount = 0;
(gdb)
77	    UTI newType = Nav; //init
(gdb)
78	    UTI idxuti = Nav;
(gdb)
80	    UTI leftType = m_nodeLeft->checkAndLabelType();
(gdb) s
MFM::NodeIdent::checkAndLabelType (this=0x8284b0) at NodeIdent.cpp:136
136	    UTI it = Nouti;  //init (was Nav)
(gdb) n
137	    u32 errCnt = 0;
(gdb)
139	    setupBlockNo(); //in case zero
(gdb)
143	    if(m_varSymbol == NULL)
(gdb)
145		UTI cuti = m_state.getCompileThisIdx(); //for error messages
(gdb)
146		NodeBlock * currBlock = getBlock();
(gdb)
147		if(m_state.useMemberBlock())
(gdb)
153		  m_state.pushCurrentBlockAndDontUseMemberBlock(currBlock);
(gdb)
155		Symbol * asymptr = NULL;
(gdb)
156		bool hazyKin = false;
(gdb)
158		if(m_state.alreadyDefinedSymbol(m_token.m_dataindex, asymptr, hazyKin))
(gdb)
160		    if(!asymptr->isFunction() && !asymptr->isTypedef() && !asymptr->isConstant() && !asymptr->isModelParameter())
(gdb)
167		    else if(asymptr->isConstant())
(gdb)
169			UTI auti = asymptr->getUlamTypeIdx();
(gdb)
172			Node * newnode = NULL;
(gdb)
174			if(m_state.isScalar(auti))
(gdb)
177			  newnode = new NodeConstantArray(m_token, (SymbolWithValue *) asymptr, m_state);
(gdb)
178			assert(newnode);
(gdb)
180			AssertBool swapOk = exchangeNodeWithParent(newnode);
(gdb)
181			assert(swapOk);
(gdb)
183			m_state.popClassContext(); //restore
(gdb)
185			delete this; //suicide is painless..
(gdb)
187			return newnode->checkAndLabelType();
(gdb) s
MFM::NodeConstantArray::checkAndLabelType (this=0x83a030)
    at NodeConstantArray.cpp:73
73	    UTI it = Nav;
(gdb) n
75	    bool stubcopy = m_state.isClassAStub(m_state.getCompileThisIdx());
(gdb)
78	    if(!stubcopy && m_constSymbol == NULL)
(gdb)
81	      stubcopy = m_state.hasClassAStub(m_state.getCompileThisIdx()); //includes ancestors
(gdb)
83	    if(m_constSymbol)
(gdb)
84	      it = m_constSymbol->getUlamTypeIdx();
(gdb)
95	    if(!m_state.isComplete(it)) //reloads to recheck
(gdb)
121	    setNodeType(it);
(gdb)
122	    Node::setStoreIntoAble(TBOOL_FALSE);
(gdb)
124	    if(!isReadyConstant())
(gdb)
132	    return it;
(gdb)
133	  } //checkAndLabelType
(gdb) s
MFM::NodeIdent::checkAndLabelType (this=0x8284b0) at NodeIdent.cpp:345
345	  } //checkAndLabelType
(gdb)
MFM::NodeSquareBracket::checkAndLabelType (this=0x828460)
    at NodeSquareBracket.cpp:83
83	    if(!m_nodeRight)
(gdb) n
94	    NodeBlock * currBlock = m_state.getCurrentBlock();
(gdb)
95	    m_state.pushCurrentBlockAndDontUseMemberBlock(currBlock); //currblock doesn't change
(gdb)
96	    UTI rightType = m_nodeRight->checkAndLabelType();
(gdb)
98	    m_state.popClassContext();
(gdb)
100	    if(m_state.isComplete(leftType))
(gdb)
102		UlamType * lut = m_state.getUlamTypeByIndex(leftType);
(gdb)
104		if(lut->isScalar())
(gdb)
164		if((errorCount == 0) && (hazyCount == 0))
(gdb)
166		    if(m_isCustomArray)
(gdb)
218			UlamType * rut = m_state.getUlamTypeByIndex(rightType);
(gdb)
219			ULAMTYPE retyp = rut->getUlamTypeEnum();
(gdb)
220			if(m_state.okUTItoContinue(rightType) && !rut->isNumericType())
(gdb)
229			else if(retyp == Class)
(gdb)
231			else if(retyp == Unary)
(gdb)
234			  idxuti = rightType; //default unless caarray
(gdb)
238		if(m_state.okUTItoContinue(idxuti) && (UlamType::compare(idxuti, rightType, m_state) == UTIC_NOTSAME))
(gdb)
262	    if((errorCount == 0) && (hazyCount == 0))
(gdb)
265		if(m_isCustomArray && m_state.isScalar(leftType))
(gdb)
268		  newType = m_state.getUlamTypeAsScalar(leftType);
(gdb)
270		if(m_isCustomArray)
(gdb)
280		  Node::setStoreIntoAble(m_nodeLeft->getStoreIntoAble());
(gdb)
270		if(m_isCustomArray)
(gdb)
294	    setNodeType(newType);
(gdb)
295	    return newType;
(gdb)
296	  } //checkAndLabelType
(gdb)
MFM::NodeConstantDef::checkAndLabelType (this=0x828400)
    at NodeConstantDef.cpp:226
226		if(it == Nav)
(gdb)
237		if(it == Hzy)
(gdb)
251		if(!m_nodeExpr->isAConstant())
(gdb)
264		if(it == Void)
(gdb)
334		if(m_state.okUTItoContinue(it) && (m_state.isScalar(it) ^ m_state.isScalar(suti)))
(gdb)
346	    if(m_state.isComplete(suti)) //reloads
(gdb)
348		ULAMTYPE eit = m_state.getUlamTypeByIndex(it)->getUlamTypeEnum();
(gdb)
349		ULAMTYPE esuti = m_state.getUlamTypeByIndex(suti)->getUlamTypeEnum();
(gdb)
350		if(m_state.okUTItoContinue(it) && (eit != esuti))
(gdb)
367		if((eit == Void))
(gdb)
388	    setNodeType(suti);
(gdb)
390	    if(!m_constSymbol->isReady() && m_nodeExpr)
(gdb)
392		UTI foldrtn = foldConstantExpression();
(gdb)
393		if(foldrtn == Nav)
(gdb)
395		else if(foldrtn == Hzy)
(gdb)
408		    if(!(m_constSymbol->isReady() || m_constSymbol->isInitValueReady()))
(gdb)
419	    return getNodeType();
(gdb)
420	  } //checkAndLabelType
(gdb)
MFM::Resolver::constantFoldNonreadyClassArgs (this=0x827b00,
    stubcsym=0x8259a0) at Resolver.cpp:332
332		    if(m_state.okUTItoContinue(uti)) //i.e. ready
(gdb)
334			delete ceNode;
(gdb)
335			*vit = NULL;
(gdb)
340		vit++;
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
343	    if(pushedtemplate)
(gdb)
345		m_state.popClassContext(); //no longer need stub context
(gdb)
346		stubclassblock->setNodeLocation(saveStubLoc);
(gdb)
349	    m_state.m_pendingArgStubContext = Nouti; //clear flag
(gdb)
350	    m_state.popClassContext(); //restore previous context
(gdb)
353	    m_nonreadyClassArgSubtrees.clear();
(gdb)
354	    if(!leftCArgs.empty())
(gdb)
356		m_nonreadyClassArgSubtrees = leftCArgs; //replace
(gdb)
357		rtnb = false;
(gdb)
359	    return rtnb;
(gdb) c
Continuing.

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x826960,
    stubcsym=0x826ab0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) n
282	    UTI context = getContextForPendingArgs();
(gdb)
283	    if(m_state.isAClass(context))
(gdb)
285		SymbolClass * contextSym = NULL;
(gdb)
286		AssertBool isDefined = m_state.alreadyDefinedSymbolClass(context, contextSym);
(gdb)
287		assert(isDefined);
(gdb)
288		NodeBlockClass * contextclassblock = contextSym->getClassBlockNode();
(gdb)
289		m_state.pushClassContext(context, contextclassblock, contextclassblock, false, NULL);
(gdb)
298	    m_state.m_pendingArgStubContext = m_classUTI; //set for folding surgery
(gdb)
300	    bool defaultval = false;
(gdb)
301	    bool pushedtemplate = false;
(gdb)
302	    assert(stubcsym);
(gdb)
303	    NodeBlockClass * stubclassblock = stubcsym->getClassBlockNode();
(gdb)
304	    assert(stubclassblock);
(gdb)
305	    Locator saveStubLoc = stubclassblock->getNodeLocation();
(gdb)
307	    std::vector<NodeConstantDef *> leftCArgs;
(gdb)
308	    std::vector<NodeConstantDef *>::iterator vit = m_nonreadyClassArgSubtrees.begin();
(gdb)
309	    while(vit != m_nonreadyClassArgSubtrees.end())
(gdb)
311		NodeConstantDef * ceNode = *vit;
(gdb)
312		if(ceNode)
(gdb)
314		    defaultval = ceNode->hasDefaultSymbolValue();
(gdb)
318		    if(defaultval && !pushedtemplate)
(gdb)
329		    assert(defaultval == pushedtemplate); //once a default, always a default
(gdb)
331		    UTI uti = ceNode->checkAndLabelType();
(gdb) p m_state.getCompileThisIdx()
$5 = 36
(gdb) p m_state.getUlamTypeNameByIndex(36)
$6 = "P(1)<36>"
(gdb) c
Continuing.
INVALID: GOT[
./Q.ulam:3:24: ERROR: Constant value expression for: a, is not a constant.
./System.ulam:2:7: ERROR: 1 Nodes with erroneous types detected after type labeling class: System.
./System.ulam:2:7: ERROR: 2 Nodes with unresolved types detected after type labeling class: System.
Unrecoverable Program Type Label FAILURE.
]
BUT EXPECTED[
Exit status: 3
Ue_P { Bool(1) b(true);  Int(32) test() {  System s;  Q(3u,3) w;  s ( 3u )print . b true = s ( b )assert . 3u cast return } }
Uq_Q(Unsigned(32) s = NONREADYCONST, Int(32) b = NONREADYCONST) { typedef Unsigned(UNKNOWN) Foo;  Unsigned(UNKNOWN) f(notready);  <NOMAIN> }
Uq_V(Int(32) a) { Unsigned(UNKNOWN) vfoo(notready);  <NOMAIN> }
Uq_System { <NOMAIN> }
]
[Inferior 1 (process 21770) exited with code 01]
(gdb) r
Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x827b00,
    stubcsym=0x8259a0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) c
Continuing.

Breakpoint 1, MFM::Resolver::constantFoldNonreadyClassArgs (this=0x826960,
    stubcsym=0x826ab0) at Resolver.cpp:281
281	    bool rtnb = true;
(gdb) p m_state.getCompileThisIdx()
$7 = 41
(gdb) p m_state.getUlamTypeNameByIndex(41)
$8 = "V(UNKNOWN)<41>"
(gdb) n
282	    UTI context = getContextForPendingArgs();
(gdb)
283	    if(m_state.isAClass(context))
(gdb) p context
$9 = 36
(gdb) p m_state.getUlamTypeNameByIndex(36)
$10 = "P(1)<36>"
(gdb) b MFM::SymbolClassNameTemplate::fixAClassStubsDefaultArgs
Breakpoint 2 at 0x4a5b68: file SymbolClassNameTemplate.cpp, line 572.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 2, MFM::SymbolClassNameTemplate::fixAClassStubsDefaultArgs (
    this=0x81c010, stubcsym=0x8259a0, defaultstartidx=0)
    at SymbolClassNameTemplate.cpp:572
572	    NodeBlockClass * templateclassblock = getClassBlockNode();
(gdb) p m_state.getCompileThisIdx()
$11 = 36
(gdb) p *stubcsym
$12 = {<MFM::Symbol> = {
    _vptr.Symbol = 0x57bdb0 <vtable for MFM::SymbolClass+16>,
    m_state = @0x7fffffffdc50, m_structuredCommentToken = {
      m_type = 4294967295, m_locator = {m_pathIdx = 0, m_fullPathIdx = 0,
        m_lineNo = 0, m_byteNo = 0}, m_dataindex = 1952543827},
    m_gotStructuredCommentToken = false, m_idtok = {
      m_type = MFM::TOK_IDENTIFIER, m_locator = {m_pathIdx = 254,
        m_fullPathIdx = 255, m_lineNo = 8, m_byteNo = 5}, m_dataindex = 258},
    m_uti = 40, m_dataMemberClass = 0, m_localfilescopeType = 0,
    m_autoLocalType = MFM::ALT_NOT, m_isSelf = false, m_isSuper = false,
    m_stBlockNo = 92}, m_resolver = 0x0, m_classBlock = 0x825720,
  m_parentTemplate = 0x81c010, m_quarkunion = false, m_stub = true,
  m_defaultValue = {static BITS_PER_UNIT = 32, static ARRAY_LENGTH = 256,
    m_bits = {0 <repeats 256 times>}}, m_isreadyDefaultValue = false,
  m_superClass = 19, m_vtable = std::vector of length 0, capacity 0}
(gdb) n
573	    assert(templateclassblock); //fails if UNSEEN during parsing
(gdb)
575	    assert(stubcsym);
(gdb)
576	    NodeBlockClass * cblock = stubcsym->getClassBlockNode();
(gdb)
577	    assert(cblock);
(gdb)
585	    u32 numparams = getNumberOfParameters();
(gdb)
586	    assert(numparams - defaultstartidx <= getTotalParametersWithDefaultValues());
(gdb)
589	    for(u32 i = defaultstartidx; i < numparams; i++)
(gdb)
591		SymbolConstantValue * paramSym = getParameterSymbolPtr(i);
(gdb) p defaultstartidx
$13 = 0
(gdb) n
592		assert(paramSym);
(gdb)
594		SymbolConstantValue * asym2 = new SymbolConstantValue(* paramSym);
(gdb) s
MFM::SymbolConstantValue::SymbolConstantValue (this=0x825e30, sref=...)
    at SymbolConstantValue.cpp:13
13	  SymbolConstantValue::SymbolConstantValue(const SymbolConstantValue & sref) : SymbolWithValue(sref), m_constantStackFrameAbsoluteSlotIndex(sref.m_constantStackFrameAbsoluteSlotIndex) {}
(gdb) p *sref
No symbol "operator*" in current context.
(gdb) p sref
$14 = (const MFM::SymbolConstantValue &) @0x81c690: {<MFM::SymbolWithValue> = {<MFM::Symbol> = {
      _vptr.Symbol = 0x57e970 <vtable for MFM::SymbolConstantValue+16>,
      m_state = @0x7fffffffdc50, m_structuredCommentToken = {
        m_type = MFM::TOK_OPEN_CURLY, m_locator = {m_pathIdx = 0,
          m_fullPathIdx = 0, m_lineNo = 0, m_byteNo = 0}, m_dataindex = 0},
      m_gotStructuredCommentToken = false, m_idtok = {
        m_type = MFM::TOK_IDENTIFIER, m_locator = {m_pathIdx = 259,
          m_fullPathIdx = 260, m_lineNo = 3, m_byteNo = 18},
        m_dataindex = 270}, m_uti = 5, m_dataMemberClass = 0,
      m_localfilescopeType = 0, m_autoLocalType = MFM::ALT_NOT,
      m_isSelf = false, m_isSuper = false, m_stBlockNo = 36},
    m_isReady = false, m_hasInitVal = true, m_isReadyInitVal = false,
    m_classParameter = true, m_classArgument = false, m_constantValue = {
      static BITS_PER_UNIT = 32, static ARRAY_LENGTH = 256, m_bits = {
        0 <repeats 256 times>}}, m_initialValue = {static BITS_PER_UNIT = 32,
      static ARRAY_LENGTH = 256, m_bits = {0 <repeats 256 times>}},
    m_declnno = 40}, m_constantStackFrameAbsoluteSlotIndex = 0}
(gdb) s
MFM::SymbolWithValue::SymbolWithValue (this=0x825e30, sref=...)
    at SymbolWithValue.cpp:8
8	  SymbolWithValue::SymbolWithValue(const SymbolWithValue & sref) : Symbol(sref), m_isReady(sref.m_isReady), m_hasInitVal(sref.m_hasInitVal), m_isReadyInitVal(false), m_classParameter(false), m_classArgument(sref.m_classArgument || sref.m_classParameter), m_declnno(sref.m_declnno)
(gdb) n
11	    m_constantValue = sref.m_constantValue;
(gdb)
12	    m_initialValue = sref.m_initialValue;
(gdb)
13	  }
(gdb) s
MFM::SymbolClassNameTemplate::fixAClassStubsDefaultArgs (this=0x81c010,
    stubcsym=0x8259a0, defaultstartidx=0) at SymbolClassNameTemplate.cpp:595
595		assert(asym2);
(gdb) n
596		asym2->setBlockNoOfST(cblock->getNodeNo()); //stub NNO same as template, at this point
(gdb) n
598		cblock->addIdToScope(asym2->getId(), asym2);
(gdb)
601		NodeConstantDef * paramConstDef = (NodeConstantDef *) templateclassblock->getParameterNode(i);
(gdb)
602		assert(paramConstDef);
(gdb)
603		NodeConstantDef * argConstDef = (NodeConstantDef *) paramConstDef->instantiate();
(gdb)
604		assert(argConstDef);
(gdb)
606		argConstDef->setSymbolPtr(asym2); //since we have it handy
(gdb)
607		stubcsym->linkConstantExpressionForPendingArg(argConstDef);
(gdb) p *argConstDef
$15 = {<MFM::Node> = {
    _vptr.Node = 0x5a1610 <vtable for MFM::NodeConstantDef+16>,
    m_state = @0x7fffffffdc50, m_utype = 0,
    m_storeIntoAble = MFM::TBOOL_FALSE, m_referenceAble = MFM::TBOOL_FALSE,
    m_loc = {m_pathIdx = 259, m_fullPathIdx = 260, m_lineNo = 3,
      m_byteNo = 9}, m_parentNo = 0, m_no = 40}, m_constSymbol = 0x825e30,
  m_nodeExpr = 0x8258b0, m_cid = 270, m_currBlockNo = 36,
  m_nodeTypeDesc = 0x827aa0}
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/elenas/WORK/ulam/repo/ULAM/bin/culamtest src/test/generic/safe/t3891_test_compiler_elementandquarkswclassargs_wdefaultparamvaluefromanotherclass_localdefconstantarrayitem.test

Breakpoint 2, MFM::SymbolClassNameTemplate::fixAClassStubsDefaultArgs (
    this=0x81c010, stubcsym=0x8259a0, defaultstartidx=0)
    at SymbolClassNameTemplate.cpp:572
572	    NodeBlockClass * templateclassblock = getClassBlockNode();
(gdb) n
573	    assert(templateclassblock); //fails if UNSEEN during parsing
(gdb)
575	    assert(stubcsym);
(gdb)
576	    NodeBlockClass * cblock = stubcsym->getClassBlockNode();
(gdb)
577	    assert(cblock);
(gdb)
585	    u32 numparams = getNumberOfParameters();
(gdb)
586	    assert(numparams - defaultstartidx <= getTotalParametersWithDefaultValues());
(gdb)
589	    for(u32 i = defaultstartidx; i < numparams; i++)
(gdb)
591		SymbolConstantValue * paramSym = getParameterSymbolPtr(i);
(gdb)
592		assert(paramSym);
(gdb)
594		SymbolConstantValue * asym2 = new SymbolConstantValue(* paramSym);
(gdb)
595		assert(asym2);
(gdb)
596		asym2->setBlockNoOfST(cblock->getNodeNo()); //stub NNO same as template, at this point
(gdb)
598		cblock->addIdToScope(asym2->getId(), asym2);
(gdb)
601		NodeConstantDef * paramConstDef = (NodeConstantDef *) templateclassblock->getParameterNode(i);
(gdb)
602		assert(paramConstDef);
(gdb)
603		NodeConstantDef * argConstDef = (NodeConstantDef *) paramConstDef->instantiate();
(gdb) s
MFM::NodeConstantDef::instantiate (this=0x81c630) at NodeConstantDef.cpp:44
44	    return new NodeConstantDef(*this);
(gdb)
MFM::NodeConstantDef::NodeConstantDef (this=0x825850, ref=...)
    at NodeConstantDef.cpp:24
24	  NodeConstantDef::NodeConstantDef(const NodeConstantDef& ref) : Node(ref), m_constSymbol(NULL), m_nodeExpr(NULL), m_cid(ref.m_cid), m_currBlockNo(ref.m_currBlockNo), m_nodeTypeDesc(NULL)
(gdb) p ref.m_cid
$16 = 270
(gdb) p m_state.m_pool.getDataAsString(270)
warning: can't find linker symbol for virtual table for `MFM::NodeConstantDef' value
$17 = <error reading variable: Cannot access memory at address 0xffffffffffffffe8>
(gdb) n
26	    if(ref.m_nodeExpr)
(gdb)
27	      m_nodeExpr = ref.m_nodeExpr->instantiate();
(gdb) s
MFM::NodeTerminalProxy::instantiate (this=0x81e270)
    at NodeTerminalProxy.cpp:27
27	    return new NodeTerminalProxy(*this);
(gdb) s
MFM::NodeTerminalProxy::NodeTerminalProxy (this=0x8258b0, ref=...)
    at NodeTerminalProxy.cpp:13
13	  NodeTerminalProxy::NodeTerminalProxy(const NodeTerminalProxy& ref) : NodeTerminal(ref), m_ofTok(ref.m_ofTok), m_uti(m_state.mapIncompleteUTIForCurrentClassInstance(ref.m_uti)), m_funcTok(ref.m_funcTok), m_ready(ref.m_ready), m_nodeTypeDesc(NULL)
(gdb) p ref.m_uti
$18 = 28
(gdb) s
MFM::NodeTerminal::NodeTerminal (this=0x8258b0, ref=...)
    at NodeTerminal.cpp:36
36	  NodeTerminal::NodeTerminal(const NodeTerminal& ref) : Node(ref), m_etyp(ref.m_etyp), m_constant(ref.m_constant) {}
(gdb)
MFM::Node::Node (this=0x8258b0, ref=...) at Node.cpp:19
19	  Node::Node(const Node & ref) : m_state(ref.m_state), m_utype(ref.m_utype), m_storeIntoAble(ref.m_storeIntoAble), m_referenceAble(ref.m_referenceAble), m_loc(ref.m_loc), m_parentNo(ref.m_parentNo), m_no(ref.m_no) /* same NNO */ {}
(gdb)
MFM::Token::Token (this=0x8258f0, tok=...) at Token.cpp:53
53	  Token::Token(const Token& tok) : m_type(tok.m_type), m_locator(tok.m_locator), m_dataindex(tok.m_dataindex) {}
(gdb)
MFM::CompilerState::mapIncompleteUTIForCurrentClassInstance (
    this=0x7fffffffdc50, suti=28) at CompilerState.cpp:761
761	    UlamType * sut = getUlamTypeByIndex(suti);
(gdb) n
762	    if(sut->isComplete())
(gdb)
765	    if(!okUTItoContinue(suti))
(gdb) p m_state.getCompileThisIdx()
No symbol "m_state" in current context.
(gdb) p getCompileThisIdx()
$19 = 36
(gdb) 