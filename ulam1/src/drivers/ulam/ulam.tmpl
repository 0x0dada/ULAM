#!/usr/bin/perl -Tw
# -*- perl -*-

####PERL CONFIG
my $ORIG_PATH = $ENV{'PATH'};
delete @ENV{'PATH', 'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

use Capture::Tiny 'capture';
use Cwd 'abs_path';
use Carp;

####DIRECTORY PATHS WITH DEFAULTS

  ##TEMPLATE SUBSTITUTIONS
  my $CULAM_PATH='@CULAM_PATH@';
  my $ULAM_SHARE_DIR='@ULAM_SHARE_DIR@';
  my $ULAM_BUILD_TIMESTAMP='@ULAM_BUILD_TIMESTAMP@';
  my $ULAM_BUILD_WHO='@ULAM_BUILD_WHO@';
  my $ULAM_BUILD_WHERE='@ULAM_BUILD_WHERE@';
  my $MFM_BUILD_VERSION='@MFM_VERSION_NUMBER@';
  my $MFM_ROOT_DIR='@MFM_ROOT_DIR@';
  IDie("Templates have not been substituted -- this is not the script you are looking for.\n")
      if $CULAM_PATH =~ /@/ or $MFM_ROOT_DIR =~ /@/;

####VARIABLES MODIFIED BY SWITCHES
my $ULAM_WORK_DIR=undef;
my $ULAM_BIN_DIR=undef;
my $SHOW_COMMANDS = 0;
my $KEEP_GOING = 0;

####TOOL PATHS
my $makeTool = "GNU Make system builder";
my $gppTool = "Compiler for C++ -> native code";
my $arTool = "Archive maker for .o files";
my $ulamcTool = "Compiler for ulam -> C++";
my $mfmRootTool = "Movable Feast Machine source distribution";

my %tools;
$tools{$ulamcTool} =
    [ $CULAM_PATH,
      sub {
          my $p = shift;
          my $status = runThis("^culam", undef, $p,"-V");
          return $status;
      }
    ];
configureMSD($MFM_ROOT_DIR);

sub getTool {
    my $tname = shift;
    my $r = $tools{$tname};
    IDie("Not tool name '$tname'")
        unless defined($r);
    return $r->[0];
}

my $gpp = findStandardTool("g++");
$tools{$gppTool} =
    [ $gpp,
      sub {
          my $p = shift;
          my $status = runThis("^g[+][+] ", undef, $p,"--version");
          return $status;
      }
    ];
my $ar = findStandardTool("ar");
$tools{$arTool} =
    [ $ar,
      sub {
          my $p = shift;
          my $status = runThis("^GNU ar ", undef, $p,"--version");
          return $status;
      }
    ];
my $make = findStandardTool("make");
$tools{$makeTool} =
    [ $make,
      sub {
          my $p = shift;
          my $status = runThis("^GNU Make", undef, $p,"--version");
          return $status;
      }
    ];
my @toolNames = ($makeTool, $gppTool, $arTool, $ulamcTool, $mfmRootTool);

sub matchOrCall {
    my ($thing, $arg) = @_;
    my $type = ref($thing);
    if ($type eq "") {
        if ($arg !~ /$thing/) {
            return "Unmatched";
        }
        return "";
    }
    if ($type eq "CODE") {
        return &$thing($stdout);
    }
    IDie("Unhandled '$thing'\n");
}

sub runThis {
    my ($matchout, $matcherr, $cmd, @args) = @_;
    if ($SHOW_COMMANDS) {
        print STDERR " ".join(" ",$cmd, @args)."\n";
    }
    my $status = "";
    my ($stdout, $stderr, $exit) = capture {
        open(HANDLE, "-|", $cmd, @args) or return "Running '$cmd' failed: $!";
        my $output = "";
        while (<HANDLE>) {
            $output .= $_;
        }
        print STDOUT $output;
        if (!close HANDLE) {
            $status = "Close failed: $?";
        }
#        return "";
    };
#    print "SOUT($stdout)\nSERR($stderr)\nEXIT($exit)\n";
    if ($exit ne "") {
        $status = $exit;
    } else {
        if (defined($matchout)) {
            $status .= matchOrCall($matchout, $stdout);
        }
        if (defined($matcherr)) {
            $status .= matchOrCall($matcherr, $stderr);
        }
    }
    return ($status,$stdout,$stderr);
}

####COMMAND LINE PROCESSING
use Getopt::Long;
use Pod::Usage;

my $actionCmd; # compile, test, etc

Getopt::Long::Configure ("gnu_getopt");    # Mostly for bundling + permute
Getopt::Long::Configure ("noauto_abbrev"); # I find auto_abbrev unnerving
#Getopt::Long::Configure ("debug");

sub findStandardTool {
    my $tname = shift;
    my $tool = `/usr/bin/which $tname`;
    chomp($tool);
    return blessShellReaching($tool);
}

sub blessShellReaching {
    my $taintedPath = shift;
     $taintedPath =~ m!^([-+_/a-zA-Z0-9]+)$!
         or UDie("'$taintedPath' contains unexpected characters!");
    return $1;
}

sub UDie {
    my $msg = shift;
    print STDERR "\nError: $msg";
    print STDERR "Type '$0 -h' for help\n";
    exit(1);
}

sub IDie {
    my $msg = shift;
    print STDERR "\nInternal Error: $msg\n";
    confess "I suck";
}

my @sections;
my %secCounts;
sub getSectionId {
    my $section = shift;
    if (!defined $secCounts{$section}) {
        $secCounts{$section} = 0;
        push @sections, $section;
    }
    my $count = $secCounts{$section}++;
    return $section.".".length($count).$count;
}

sub getSectionNames {
    return @sections;
}

my %swinfo = (
    "help" => {
        aliases => "h|?",
        desc => "Print this help, then exit",
        id => getSectionId("Information"),
        handler => \&entryOcmd
    },
    "briefversion" => {
        aliases => "V",
        desc => "Print minimal version information, then exit",
        id => getSectionId("Information"),
        handler => \&entryOcmd
    },
    "version" => {
        aliases => "",
        desc => "Print full version information, then exit",
        id => getSectionId("Information"),
        handler => \&entryOcmd
    },
    "checktools" => {
        aliases => "C",
        desc => "Report tool paths; exit successfully if all are found",
        id => getSectionId("Information"),
        handler => \&entryOcmd
    },
    "executables" => {
        aliases => "e",
        desc => "Generate executable  binaries from .ulam (implies --library)",
        id => getSectionId("Command"),
        handler => \&entryCmd
    },
    "library" => {
        aliases => "l",
        desc => "Create .a library file .ulam (implies --compile)",
        id => getSectionId("Command"),
        handler => \&entryCmd
    },
    "compile" => {
        aliases => "c",
        desc => "Compile .ulam to .o object files (implies --ulamcompile)",
        id => getSectionId("Command"),
        handler => \&entryCmd
    },
    "ulamtest" => {
        aliases => "ut",
        desc => "Generate the ulamtest binary from .ulam (implies --compile)",
        id => getSectionId("Command"),
        handler => \&entryCmd
    },
    "test" => {
        aliases => "t",
        desc => "Run the ulamtest binary (implies --ulamtest)",
        id => getSectionId("Command"),
        handler => \&entryCmd
    },
    "sourceDir" => {
        aliases => "sd",
        type => "s",
        desc => "Directory containing source .ulam files",
        default => ".",
        id => getSectionId("Option"),
        handler => \&entryOpt
    },
    "workDir" => {
        aliases => "wd",
        type => "s",
        desc => "Work directory for all compiler files",
        variable => \$ULAM_WORK_DIR,
        id => getSectionId("Option"),
        handler => \&entryVar
    },
    "outputDir" => {
        aliases => "od",
        type => "s",
        desc => "Directory for final compiled outputs",
        variable => \$ULAM_BIN_DIR,
        id => getSectionId("Option"),
        handler => \&entryVar
    },
    "mfmSourceDir" => {
        aliases => "msd",
        type => "s",
        desc => "Root of the MFM source tree",
        default => "$MFM_ROOT_DIR",
        id => getSectionId("Option"),
        handler => \&entryOpt
    },
    "ulamcompile" => {
        aliases => "uc",
        desc => "Compile .ulam to intermediate C++ and stop",
        id => getSectionId("Debugging"),
        handler => \&entryCmd
    },
    "showcommands" => {
        aliases => "sc",
        desc => "Print commands before running them",
        variable => \$SHOW_COMMANDS,
        id => getSectionId("Debugging"),
        handler => \&entryVar
    },
    "keepGoing" => {
        aliases => "k",
        desc => "Don't abort overall compilation on errors",
        variable => \$KEEP_GOING,
        id => getSectionId("Option"),
        handler => \&entryVar
    },
    );

my $maxSwitchNameSize;
sub ComputeMaxSwitchNameSize {
    my $max = 0;
    for my $key (keys %swinfo) {
        my $swnames = getSwNameList($key);
        my $len = length($swnames);
        if ($len > $max) {
            $max = $len;
        }
    }
    $maxSwitchNameSize = $max;
}
ComputeMaxSwitchNameSize();

sub printSummaryHelp
{
    print STDERR "\nThis is the top-level ulam compilation driver\n";
    print STDERR "\nBasic command forms:\n";
    print STDERR "  $0 [OPTIONSWITCHES] INFOSWITCH\n";
    print STDERR "  $0 [OPTIONSWITCHES] COMMANDSWITCH File1.ulam File2.ulam...\n";
    print STDERR "\n";
}

sub printSectionsHelp
{
    my @sections = @_;
    @sections = getSectionNames()
        unless scalar(@sections) > 0;
    for my $section (@sections) {
        printSectionHelp($section);
    }
}

sub getSectionSwitchList {
    my $section = shift or IDie;
    my %secs;
    for my $key (keys %swinfo) {
        my $rinfo = $swinfo{$key};
        my $id = $rinfo->{"id"};
        my ($sect,$num) = split(/[.]/, $id);
        next unless $sect eq $section;
        $secs{$num} = $key;
    }
    my @ret;
    for my $key (sort keys %secs) {
        push @ret, $secs{$key}
    }
    return @ret;
}

sub printSwitchHelp {
    my $switch = shift or IDie;
    my $swnames = getSwNameList($switch);
    my $rinfo = getSwinfo($switch);
    my $desc = $rinfo->{"desc"} or die "No desc for '$switch' you moke";
    my $default = $rinfo->{"default"};
    if (defined($default)) {
        my $delim = "";
        my $type = $rinfo->{"type"};
        $delim = "'" if $type eq "s";
        $desc .= "; default: $delim$default$delim";
    }
    my $width = $maxSwitchNameSize + 2;
    printf STDERR "%${width}s  %s\n",$swnames,$desc;
}

sub printSectionHelp {
    my $section = shift or IDie;
    print STDERR "$section switches:\n";
    for my $switch (getSectionSwitchList($section)) {
        printSwitchHelp($switch);
    }
    print STDERR "\n";
}

sub printHelp {
    printSummaryHelp();
    printSectionsHelp();
}

sub printToolPath {
    my $toolName = shift;
    return checkTool($toolName,1);
}

sub checkTool {
    my ($toolName, $printit) = @_;
    my $rl = $tools{$toolName};
    my $toolPath = $rl->[0];
    my $toolSub = $rl->[1];

    my $status;
    if (!defined($toolPath) || $toolPath eq "") {
        $toolPath = "";
        $status = "Not configured";
    } else {
        $status = &$toolSub($toolPath);
    }
    my $statName = "OK";
    my $prefix = "    ";
    if ($status ne "") {
        $statName = "PROBLEM: $status";
        $prefix = "X-> ";
    }
    if (defined($printit) && $printit) {
        print STDERR "  $toolName:\n    Path='$toolPath'\n${prefix}Status=$statName\n";
    }
    return $status eq "";
}

sub printVersion {
    print STDERR "$MFM_BUILD_VERSION\n";
}

sub printFullVersion {
    print STDERR "ulam $ULAM_BUILD_TIMESTAMP, built on MFM $MFM_BUILD_VERSION by $ULAM_BUILD_WHO\@$ULAM_BUILD_WHERE\n";
}

sub printToolPathsAndExit {
    my $status = 0;
    for my $tool (@toolNames) {
        $status++ unless printToolPath($tool);
    }
    exit $status;
}

sub pISC {
    return unless $SHOW_COMMANDS;
    my $arg = shift;
    print STDERR "$arg\n";
}

sub checkTools {
    pISC("## Check tools");
    my $status = 0;
    for my $tool (@toolNames) {
        my $r = checkTool($tool);
        $status++ unless $r;
    }
    return $status;
}

sub getSwinfo {
    my $key = shift;
    my $rinfo = $swinfo{$key};
    IDie("No '$key' info")
        unless defined $rinfo;
    return $rinfo;
}

sub getSwNameList {
    my $key = shift;
    my $joiner = shift;
    $joiner = "," unless defined $joiner;
    my $rinfo = getSwinfo($key);
    my $ret = "--$key";
    my $aliases = $rinfo->{"aliases"} || "";
    for my $key (split /\|/, $aliases) {
        if (length($key)==1) {
            $ret .= "$joiner -$key";
        } else {
            $ret .= "$joiner --$key";
        }
    }
    return $ret;
}

sub configureMSD {
    my $path = shift;
    $MFM_ROOT_DIR = $path;
    $tools{$mfmRootTool} =
        [ $MFM_ROOT_DIR,
          sub {
              my $p = shift;
              my $status = runThis("^MFMsim",undef,
                                    getTool($makeTool),
                                   "--no-print-directory",
                                    "-C",
                                    "$p",
                                    "identify"
                                   );
              return $status;
          }
        ];
}

sub configureSD {
    my $path = shift;
    IDie("configureSD($path) -- how default update/merge etc\n");
}

sub entryOpt {
    my ($key, $val) = @_;
    return configureMSD($val) if $key eq "mfmSourceDir";
    return configureSD($val) if $key eq "sourceDir";
    IDie("Unrecognized entryOpt($key,$val)\n");
}

my %entryVarsAlreadySeen;
sub entryVar {
    my ($switch, $val) = @_;
    my $rinfo = getSwinfo($switch);
    my $vref = $rinfo->{'variable'};
    IDie unless defined $vref;
    UDie getSwNameList($switch," or")." can appear at most once\n"
        if defined $entryVarsAlreadySeen{$switch};
    $entryVarsAlreadySeen{$switch} = 1;
    $$vref = $val;
}

sub entryCmd {
    my ($key, $val) = @_;
    UDie "Cannot specify "
        .getSwNameList($key," or")
        ." with "
        .getSwNameList($actionCmd," or")
        ."\n"
        if defined($actionCmd) && $actionCmd ne $key;
    $actionCmd = $key;
}

sub entryOcmd {
    my ($key, $val) = @_;
    if ($key eq "help") {
        printHelp();
        exit;
    }
    if ($key eq "briefversion") {
        printVersion();
        exit;
    }
    if ($key eq "version") {
        printFullVersion();
        exit;
    }
    if ($key eq "checktools") {
        printToolPathsAndExit();
    }
    IDie "unknown OCmd($key)\n";
}

sub genOpts {
    my @list;
    for my $key (keys %swinfo) {
        my $r = $swinfo{$key};
        my $optkey = $key;
        $optkey .= "|$r->{aliases}"
            if defined($r->{"aliases"});
        $optkey .= "=$r->{type}"
            if defined($r->{"type"});
        my $optval = $r->{"handler"};
        unshift @list, $optkey, $optval;
    }
#    print join(" ",@list);
    return @list;
}

sub natatime ($@)
{
    my $n = shift;
    my @list = @_;

    return sub
    {
        return splice @list, 0, $n;
    }
}

GetOptions(genOpts())
     or UDie("Command line switch processing failed\n");

sub process {
    my $foo = shift;
    print "PROCESS($foo)\n";
}

sub getArgHref {
    my $matching = shift;
    my %ret;
    for my $key (keys %{$o}) {
        next unless $key =~ /^$matching/;
        my $val = defined $o->{$key};
        next unless $val;
        $ret{$key} = $val;
    }
    return \%ret;
}

my $confErrs = checkTools();
if ($confErrs != 0) {
    printf(STDERR
           "%d configuration problem%s detected!\n",
           $confErrs, $confErrs==1?"":"s");
    printToolPathsAndExit();
}

my @files = @ARGV;
UDie("No input files\n") unless @files;
my (@ulamFiles, @includeFiles, @otherSrcFiles);
my %extensionDispatch = (
    "ulam" => \@ulamFiles,
    "h" => \@includeFiles,
    "tcc" => \@includeFiles,
    "cpp" => \@otherSrcFiles,
    "c" => \@otherSrcFiles,
    "S" => \@otherSrcFiles
    );


sub separateFiles {
    my @f = @_;
    while (my $file = shift @f) {
        my $handled = 0;
        if ($file =~ /[.]([^.]+)$/) {
            my $ext = $1;
            my $ar = $extensionDispatch{$ext};
            if (defined $ar) {
                push @{$ar}, $file;
                $handled = 1;
            }
        }
        print STDERR "Warning: Skipping unrecognized file type '$file'\n"
            unless $handled;
    }
}
my $usdfiles = `ls $ULAM_SHARE_DIR/ulam/*.ulam`;
chomp($usdfiles);
my @stdUlamFiles = split(/\s+/,$usdfiles);

my $tsdfiles = `ls $ULAM_SHARE_DIR/tcc/*.tcc`;
chomp($tsdfiles);
my @stdTccFiles = split(/\s+/,$tsdfiles);

# Barf; need to compile the stdUlamFiles to get the mangled names into
# @elementNamesFromUlam, and thence into AllocateEmptyTypes()..
separateFiles(@files, @stdUlamFiles, @stdTccFiles);

sub positionLiteralFiles {
    pISC("## Copy files");
    my $bd = getWorkDir();
    copyFilesTo("$bd/include",@includeFiles);
    copyFilesTo("$bd/src",@otherSrcFiles);
}

sub copyFilesTo {
    my ($destPath, @files) = @_;
    for my $file (@files) {
        copyFileTo($file,$destPath);
    }
}

sub copyFileTo {
    my ($file, $destDir) = @_;
    -d $destDir or IDie("'$destDir' not dir");
    my ($status,$stdout,$stderr) = runThis(undef,undef,'/bin/cp',"-p",$file,$destDir);
    UDie("Can't copy '$file' to '$destDir': $status\n") if $status ne "";
}

####ACTION SELECTION
UDie("No command specified\n")
    unless defined($actionCmd);

####EXECUTION ENGINE

# Well, let's actually try to do something here

exit compilationDriver();

my @cppFromUlam;
my @elementNamesFromUlam;

sub compilationDriver {
    prepareWorkDir();
    positionLiteralFiles();

    my $buildResults = runUlamCompilations();
    UDie("$buildResults ulam build problem(s) detected\n")
        if $buildResults;

    return 0 if $actionCmd eq "ulamcompile";

    if ($actionCmd eq "test") {
        ($buildResults, my $testfile) = buildTests();
        UDie("$buildResults tests creation problem(s) detected\n")
            if $buildResults;
#        IDie("Do what with $testfile?");
        push @cppFromUlam, $testfile;
    }

    ($buildResults, my $allocatorcpp) = writeElementAllocatorStub();
    UDie("$buildResults stub creation problem(s) detected\n")
        if $buildResults;

    $buildResults = runGccCompilations();
    UDie("$buildResults g++ build problem(s) detected\n")
        if $buildResults;

    return 0 if $actionCmd eq "compile";

    ($buildResults, my $libfile) = buildLibrary();
    UDie("$buildResults library creation problem(s) detected\n")
        if $buildResults;

    return 0 if $actionCmd eq "library";

    if ($actionCmd eq "executables") {
        ($buildResults) = buildExecutables();
        UDie("$buildResults executable creation problem(s) detected\n")
            if $buildResults;
        return 0;
    } else {
        ($buildResults) = buildTestMain();
        UDie("$buildResults test main creation problem(s) detected\n")
            if $buildResults;
        ($buildResults,my $exefile) = makeProgram("testmain");
        UDie("$buildResults testdriver linking problem(s) detected\n")
            if $buildResults;
        return 0;
    }
}

sub myMkdir {
    my $path = shift;
    my ($status,$stdout,$stderr) = runThis(undef,undef,'/bin/mkdir',"-p",$path);
    UDie("Can't make dir '$path': $status\n") if $status ne "";
}

sub checkOrMakeDir
{
    my $bd = shift;
    if (!-e $bd) {
        myMkdir($bd);
    } else {
        pISC(" # Exists: $bd");
    }

    UDie "'$bd' is not a directory\n" unless -d $bd;
    UDie "'$bd' is not accessible\n" unless -R $bd and -W $bd;
}

sub prepareWorkDir
{
    defaultWorkDir();
    pISC("## Make dirs");
    my $bd = getWorkDir();
    checkOrMakeDir($bd);
    checkOrMakeDir("$bd/src");
    checkOrMakeDir("$bd/include");
    checkOrMakeDir("$bd/build");
    checkOrMakeDir("$bd/bin");
}

my %testableFiles;

sub runGccMakeForTests
{
    my @testables = map { s/[.]cpp$//; $_} sort values %testableFiles;
    print "TEST:".join(",", @testables)."\n";
    my $body = "";
    for my $test (@testables) {
        $body .= <<EOM;
 XXX
EOM
    }

    IDie("Implementme $actionCmd:$body\n");
}

sub runUlamCompilations
{
    pISC("## Compile ulam");
    my $status = 0;
    for my $file (@ulamFiles) {
        pISC(" # Compiling '$file'");
        my ($ulamStatus, $cfile, $testable) = runUlamCompile($file);
        my $gppStatus = 0;
#        print STDERR "RUC($ulamStatus, $cfile, $testable) = runUlamCompile($file);\n";
        if ($ulamStatus == 0) {
            if ($testable) {
                $testableFiles{$file} = $cfile;
            }
            push @cppFromUlam, $cfile;
            if ($cfile =~ /^(Ue_[^.]+)[.]cpp/) {
                my $eltName = $1;
                push @elementNamesFromUlam, $eltName;
            }
        }
        my $fileStatus = $ulamStatus + $gppStatus;
        $status += $fileStatus;
        last if $fileStatus != 0 && $KEEP_GOING == 0;
    }
    return $status;
}

sub writeElementAllocatorStub {
    my $base = "UlamCustomElements";
    my $baseguard = uc($base)."_H";
    my $hdr = "$base.h";
    my $cpp = "$base.cpp";
    my $inc = "$ULAM_WORK_DIR/include/$hdr";
    my $src = "$ULAM_WORK_DIR/src/$cpp";
    my $fname = "DefineNeededUlamCustomElements";

    open(my $hdrhdl, ">", $inc)
        or UDie("Can't write '$inc': $!\n");
    print $hdrhdl <<EOF;
#ifndef $baseguard
#define $baseguard

#include "AbstractDriver.h"
EOF
    for my $en (@elementNamesFromUlam) {
      print $hdrhdl <<EOF;
#include "$en.h"
EOF
    }

    print $hdrhdl <<EOF;

namespace MFM {
  template <class GC>
  void $fname(AbstractDriver<GC> * ad)
  {
    typedef typename GC::CORE_CONFIG CC;
EOF
    for my $en (@elementNamesFromUlam) {
        if ($en eq "Ue_10105Empty") {
          print $hdrhdl <<EOF;
    MFM::$en<CC>::THE_INSTANCE.MakeAlternateNameForTestingInternal(MFM::Element_Empty<CC>::THE_INSTANCE);
EOF
        } else {
            print $hdrhdl "    ad->NeedElement(&$en<CC>::THE_INSTANCE);\n";
        }
    }
    print $hdrhdl <<EOF;
  }
} // MFM
#endif /* $baseguard */
EOF

    close $hdrhdl or UDie("Error closing '$inc': $!\n");
    open(my $handle, ">", $src)
        or UDie("Can't write '$src': $!\n");
    print $handle <<EOF;

#include "$hdr"

EOF
    close $handle or UDie("Error closing '$src': $!\n");
    return (0,$cpp);
}

sub buildLibrary
{
    pISC("## Create library");
    my $libfile = "$ULAM_WORK_DIR/build/libculam.a";
    my @args = ("ruc", $libfile);
    my $status = 0;
    for my $cfile (@cppFromUlam) {
        my $ofile = $cfile;
        if ($ofile !~ s/[.]cpp$/.o/) {
            IDie("What happened? ($cfile)\n");
        }
        $ofile = "$ULAM_WORK_DIR/build/$ofile";
        push @args, $ofile;
    }

    print " Create library: ";
    my $ar = getTool($arTool);
    ($status,my $stdout,my $stderr) = runThis(undef,undef,$ar,@args);

    if ($status ne "") {
        print STDOUT "ERROR: $status\n$stderr\n";
    } else {
#        my $info = $stderr;
#        chomp($info);
#        print STDOUT "INFO($info)\n";
#        my ($cfile, $hastest) = split(/ /, $info);
        print STDOUT "OK\n";
        return (0, $libfile);
    }
    return $status ne "";
}

sub buildExecutables
{
    pISC("## Create executables");
    return buildSimDriver();
    IDie("IMPLEMENTME");
    my $libfile = "$ULAM_WORK_DIR/build/libculam.a";
    my @args = ("ruc", $libfile);
    my $status = 0;
    for my $cfile (@cppFromUlam) {
        my $ofile = $cfile;
        if ($ofile !~ s/[.]cpp$/.o/) {
            IDie("What happened? ($cfile)\n");
        }
        $ofile = "$ULAM_WORK_DIR/build/$ofile";
        push @args, $ofile;
    }

    print " Create library: ";
    my $ar = getTool($arTool);
    ($status,my $stdout,my $stderr) = runThis(undef,undef,$ar,@args);

    if ($status ne "") {
        print STDOUT "ERROR: $status\n$stderr\n";
    } else {
#        my $info = $stderr;
#        chomp($info);
#        print STDOUT "INFO($info)\n";
#        my ($cfile, $hastest) = split(/ /, $info);
        print STDOUT "OK\n";
        return (0, $libfile);
    }
    return $status ne "";
}

sub generateTestForTestable {
    my ($handle, $elementName) = @_;
    my $elementTestFuncName = "Test_$elementName";
    print $handle <<EOF;

#include "$elementName.h"
static int $elementTestFuncName(bool output)
{
  enum { SIZE = 96 };
  typedef MFM::ParamConfig<SIZE> OurParamConfig;
  typedef MFM::P3Atom<OurParamConfig> OurAtom;
  typedef MFM::CoreConfig<OurAtom, OurParamConfig> OurCoreConfig;

  AllocateElementTypes<OurCoreConfig>();

  typedef MFM::UlamContext<OurCoreConfig> OurUlamContext;
  typedef MFM::Tile<OurCoreConfig> OurTile;
  typedef MFM::EventWindow<OurCoreConfig> OurEventWindow;
  OurTile theTile;
  theTile.Init();
  OurUlamContext & ouc = OurUlamContext::Get();
  ouc.SetTile(theTile);
  OurEventWindow & ew = ouc.GetEventWindow();
  MFM::s32 ctr = theTile.GetTileWidth()/2;
  if (!ew.InitForEvent(MFM::SPoint(ctr,ctr)))
    return 99;
  typedef MFM::$elementName<OurCoreConfig> OurElement;
  OurElement& elt = OurElement::THE_INSTANCE;
  OurAtom atom = elt.GetDefaultAtom();
  ew.SetCenterAtom(atom);

  MFM::Ui_Ut_102323Int rtn;
  rtn = OurElement::Uf_4test(atom);
  int count = rtn.read();
  if (output) {
    if (count == 0)
      printf("%s: OK\\n","$elementTestFuncName");
    else
      printf("%s: ERROR RETURN %d\\n","$elementTestFuncName", count);
  }
  return count;
}

EOF
    return $elementTestFuncName;
}

sub buildTests
{
    pISC("## Create test driver");

    # Goal 1: Have a prewritten test function that sets up a test
    #         environment.  Stored where?
    #
    # Goal 2: Have a prewritten test driver that has a small amount of
    #         generated code each testable element, that sets up the
    #         test environment, puts an instance of the
    #         element-under-test (EUT) into the center site, and then
    #         calls Uf_4test appropriately for that element.  This way
    #         we require no base class declaration of the test function.

    my $testbase = "testdriver";
    my $testbaseguard = uc($testbase)."_H";
    my $testhdr = "$testbase.h";
    my $testcpp = "$testbase.cpp";
    my $testinc = "$ULAM_WORK_DIR/include/$testhdr";
    my $testsrc = "$ULAM_WORK_DIR/src/$testcpp";

    my $testdecl = "int RunAllTests(bool output)";
    open(my $hdrhdl, ">", $testinc)
        or UDie("Can't write '$testinc': $!\n");
    print $hdrhdl <<EOF;
#ifndef $testbaseguard
#define $testbaseguard

 extern $testdecl;

#endif /* $testbaseguard */
EOF
    close $hdrhdl or UDie("Error closing '$testinc': $!\n");
    open(my $handle, ">", $testsrc)
        or UDie("Can't write '$testsrc': $!\n");
    print $handle <<EOF;

#include "$testhdr"

EOF
    for my $en (@elementNamesFromUlam) {
      print $handle <<EOF;
#include "$en.h"
EOF
    }

    print $handle <<EOF;

template <class CC>
static void AllocateElementTypes()
{
  static bool initted = false;
  if (initted) return;
  initted = true;
EOF
    for my $en (@elementNamesFromUlam) {
        if ($en eq "Ue_10105Empty") {
          print $handle <<EOF;
  MFM::$en<CC>::THE_INSTANCE.MakeAlternateNameForTestingInternal(MFM::Element_Empty<CC>::THE_INSTANCE);
EOF
        } else {
          print $handle <<EOF;
  MFM::$en<CC>::THE_INSTANCE.AllocateType();
EOF
        }
    }
    print $handle <<EOF;
}

EOF
    my @testables = map { s/[.]cpp$//; $_} sort values %testableFiles;

    my @testfuncs;
    for my $eltName (@testables) {
        my $testcpp = generateTestForTestable($handle, $eltName);
        push @testfuncs, $testcpp;
    }
    print $handle <<EOF;

$testdecl
{
  int testsFailed = 0;

EOF
    for my $testfunc (@testfuncs) {
        print $handle <<EOF;
  testsFailed += $testfunc(output);
EOF
   }
    print $handle <<EOF;
  return testsFailed > 99 ? 99 : testsFailed;
}
EOF
    close $handle or UDie("Error closing '$testsrc': $!\n");
   return (0,$testcpp);
}

sub buildTestMain
{
    pISC("## Create test main");

    my $testbase = "testdriver";
    my $testhdr = "$testbase.h";

    my $testsrc = "$ULAM_WORK_DIR/src/testmain.cpp";

    open(my $handle, ">", $testsrc)
        or UDie("Can't write '$testsrc': $!\n");
    print $handle <<EOF;
#include "$testhdr"

int main(int argc, char **argv) {
  return RunAllTests(argc > 1);
}
EOF
    close $handle or UDie("Error closing '$testsrc': $!\n");
   return (0,$testbase);
}

sub buildSimDriver
{
    pISC("## Build custom simulator");
    my $dir = getWorkDir();

    my $linkFailed =
        runMake("all",
                "DEBUG=1",
                "EXTERNAL_DEFINES=-Wno-error=unused-variable -DULAM_CUSTOM_ELEMENTS",
                "EXTERNAL_INCLUDES=-I $dir/include",
                "EXTERNAL_LIBS=-L $dir/build -l culam",
        );
    UDie("What") if $linkFailed;
}


sub runGccCompilations
{
    pISC("## Compile C++");
    my $status = 0;
    my $dir = getWorkDir();
    for my $cfile (@cppFromUlam) {
        pISC(" # Compiling '$cfile'");
        my $gppStatus = 0;
        $gppStatus =
            gppCompile($cfile,"ulam_cppcompile",
                       "COMMANDS","1",
                       "EXTERNAL_DEFINES", "-Wno-error=unused-variable -I $ULAM_SHARE_DIR/tcc",
                       "ULAM_SRC_DIR", "$dir/src",
                       "ULAM_CPP_FILE", $cfile,
                       "ULAM_BLD_DIR", "$dir/build",
                       "ULAM_BIN_DIR", "$dir/bin",
                       "MFM_ROOT_DIR", $MFM_ROOT_DIR,
                       "USE_PATH", $ORIG_PATH
            );
        my $fileStatus = $gppStatus;
        $status += $fileStatus;
        last if $fileStatus != 0 && $KEEP_GOING == 0;
    }
    return $status;
}

sub makeProgram
{
    my $progname = shift;
    pISC("## Create program $progname");
    my $gppStatus = 0;
    $gppStatus = gppCompile("$progname.cpp","ulam_program");
    return ($gppStatus,$progname);
}

sub runUlamCompile {
    my ($file) = @_;
    my $culam = getTool($ulamcTool);
    my @args = ($file);
    push @args, $ULAM_WORK_DIR
        if defined $ULAM_WORK_DIR;
    print " Compile $file: ";
    my ($status,$stdout,$stderr) = runThis(undef,undef,$culam,@args);
    if ($status ne "") {
        print STDOUT "ERROR: $status\n$stderr\n";
    } else {
        my $info = $stderr;
        chomp($info);
#        print STDOUT "INFO($info)\n";
        my ($cfile, $hastest) = split(/ /, $info);
        print STDOUT "OK\n";
        return (0, $cfile, $hastest eq 'TEST');
    }
    return $status ne "";
}

sub UNSAFE_TEMPORARY_MV_FILES
{
    my $bd = shift;
    $bd =~ /^(.*)$/ or die;
    $bd = $1;
    system("/bin/mv $bd/*.h $bd/*.tcc $bd/include");
    system("/bin/mv $bd/*.cpp $bd/src");
}

sub printEnv {
    my $pref = shift;
    for my $key (sort keys %ENV) {
        print "$pref $key=$ENV{$key}\n";
    }
}

sub modifyEnv {
    my @kv = @_;
    my %OLDENV = %ENV;
    while (@kv) {
        my $key = shift @kv;
        IDie if scalar @kv == 0;
        my $val = shift @kv;
        $ENV{$key} = $val;
    }
    return \%OLDENV;
}

sub restoreEnv {
    my $oldEref = shift;
    %ENV = %{$oldEref};
}

sub changeEnv {
    printEnv("BEFORE");
    my $save = modifyEnv("iamgod","psfdhfsd","key",43);
    printEnv("MIDDLE");
    restoreEnv($save);
    printEnv("AFTERR");
    exit(2);
}

sub defaultWorkDir {
    $ULAM_WORK_DIR = "./.gen"
        unless defined $ULAM_WORK_DIR;
    $ULAM_WORK_DIR = abs_path($ULAM_WORK_DIR);
    if ($ULAM_WORK_DIR =~ m!^([-_a-zA-Z0-9./]+)$!) {
        $ULAM_WORK_DIR = $1;
    }
}

sub getWorkDir {
    die unless defined $ULAM_WORK_DIR;
    return $ULAM_WORK_DIR;
}

sub gppCompile {
    my ($file,$makeTarget,@extraEnvPairs) = @_;
    my $make = getTool($makeTool);
    my $mfm = getTool($mfmRootTool);
    my @env;
    while (my $key = shift @extraEnvPairs) {
        my $val = shift @extraEnvPairs;
        push @env, $key, $val;
    }
    my $oldenv = modifyEnv(@env);
    my @args = ("-e",
		"-C", "$mfm", $makeTarget);
    print " Compile $file: ";
    my ($status,$stdout,$stderr) = runThis(undef,undef,$make,@args);
    restoreEnv($oldenv);
    if ($status ne "") {
        print STDOUT "ERROR: $status\nstdout={$stdout}\nstderr=$stderr\n";
    } else {
        print STDOUT "OK\n";
    }
    return $status ne "";
}

sub runMake {
    my ($makeTarget,@args) = @_;
    my $make = getTool($makeTool);
    my $mfm = getTool($mfmRootTool);
    my @env = ("MFM_ROOT_DIR", $MFM_ROOT_DIR, "USE_PATH", $ORIG_PATH);
    my $oldenv = modifyEnv(@env);
    unshift @args,"-e","-C", "$mfm", $makeTarget;
    print " Make $makeTarget: ";
    my ($status,$stdout,$stderr) = runThis(undef,undef,$make,@args);
    restoreEnv($oldenv);
    if ($SHOW_COMMANDS) {
        print STDOUT $stdout;
    }
    if ($status ne "") {
        print STDOUT "runMake ERROR: $status\nstdout={$stdout}\nstderr=$stderr\n";
    } else {
        print STDOUT "OK\n";
    }
    return $status ne "";
}

####POD
#pod2usage(1) if $help;
#pod2usage(-exitstatus => 0, -verbose => 2) if $man;

=head1 NAME

sample - Using Getopt::Long and Pod::Usage

=head1 SYNOPSIS

sample [options] [file ...]

 Options:
   -help            brief help message
   -man             full documentation

=head1 OPTIONS

=over 8

=item B

Print a brief help message and exits.

=item B

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B will read the given input file(s) and do something
useful with the contents thereof.
