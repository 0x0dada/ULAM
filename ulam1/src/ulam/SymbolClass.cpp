#include <sstream>
#include <string.h>
#include "CompilerState.h"
#include "SymbolClass.h"
#include "SymbolClassName.h"
#include "Resolver.h"

namespace MFM {

  static const char * CModeForHeaderFiles = "/**                                      -*- mode:C++ -*- */\n\n";

  // First line something like: "/* NodeProgram.h - Root Node of Programs for ULAM\n"
  static const char * CopyrightAndLicenseForUlamHeader =   "*\n"
    "**********************************************************************************\n"
    "* This code is generated by the ULAM programming language compilation system.\n"
    "*\n"
    "* The ULAM programming language compilation system is free software:\n"
    "* you can redistribute it and/or modify it under the terms of the GNU\n"
    "* General Public License as published by the Free Software\n"
    "* Foundation, either version 3 of the License, or (at your option)\n"
    "* any later version.\n"
    "*\n"
    "* The ULAM programming language compilation system is distributed in\n"
    "* the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n"
    "* even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n"
    "* PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
    "* details.\n"
    "*\n"
    "* You should have received a copy of the GNU General Public License\n"
    "* along with the ULAM programming language compilation system\n"
    "* software.  If not, see <http://www.gnu.org/licenses/>.\n"
    "*\n"
    "* @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n"
    "*/\n\n";

  SymbolClass::SymbolClass(u32 id, UTI utype, NodeBlockClass * classblock, SymbolClassName * parent, CompilerState& state) : Symbol(id, utype, state), m_resolver(NULL), m_classBlock(classblock), m_parentTemplate(parent), m_quarkunion(false), m_deep(false){}

  SymbolClass::SymbolClass(const SymbolClass& sref) : Symbol(sref), m_resolver(NULL), m_parentTemplate(sref.m_parentTemplate), m_quarkunion(sref.m_quarkunion), m_deep(true)
  {
    if(sref.m_classBlock)
      {
	m_classBlock = (NodeBlockClass * ) sref.m_classBlock->instantiate(); //note: wasn't correct uti during cloning
	m_classBlock->setNodeType(sref.m_utypeIdx);
      }
    else
      m_classBlock = NULL; //i.e. UC_INCOMPLETE

    if(sref.m_resolver)
      m_resolver = new Resolver(m_utypeIdx, m_state); //not a clone, populated later
  }

  SymbolClass::~SymbolClass()
  {
    delete m_classBlock;
    m_classBlock = NULL;

    if(m_resolver)
      {
	delete m_resolver;
	m_resolver = NULL;
      }
  }

  Symbol * SymbolClass::clone()
  {
    assert(0);
    return new SymbolClass(*this);
  }

  void SymbolClass::setClassBlockNode(NodeBlockClass * node)
  {
    m_classBlock = node;
    Symbol::setBlockNoOfST(node->getNodeNo());
  }

  NodeBlockClass * SymbolClass::getClassBlockNode()
  {
    return m_classBlock;
  }

  SymbolClassName * SymbolClass::getParentClassTemplate()
  {
    return m_parentTemplate; //could be self
  }

  bool SymbolClass::isClass()
  {
    return true;
  }

  bool SymbolClass::isClassTemplate(UTI cuti)
  {
    return false;
  }

  const std::string SymbolClass::getMangledPrefix()
  {
    return m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamTypeUPrefix();
  }

  ULAMCLASSTYPE SymbolClass::getUlamClass()
  {
    return  m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamClass();
  }

  void SymbolClass::setUlamClass(ULAMCLASSTYPE type)
  {
    ((UlamTypeClass * ) m_state.getUlamTypeByIndex(getUlamTypeIdx()))->setUlamClass(type);
  }

  void SymbolClass::setQuarkUnion()
  {
    m_quarkunion = true;
  }

  bool SymbolClass::isQuarkUnion()
  {
    return m_quarkunion;
  }

  bool SymbolClass::isDeep()
  {
    return m_deep;
  }

  void SymbolClass::setDeep()
  {
    m_deep = true;
  }

  bool SymbolClass::trySetBitsizeWithUTIValues(s32& totalbits)
  {
    NodeBlockClass * classNode = getClassBlockNode(); //instance
    bool aok = true;

    //of course they always aren't! but we know to keep looping..
    UTI suti = getUlamTypeIdx();
    if(! m_state.isComplete(suti))
      {
	std::ostringstream msg;
	msg << "Incomplete Class Type: "  << m_state.getUlamTypeNameByIndex(suti).c_str() << " (UTI" << suti << ") has 'unknown' sizes, fails sizing pre-test while compiling class: " << m_state.getUlamTypeNameByIndex(m_state.m_compileThisIdx).c_str();
	MSG(m_state.getFullLocationAsString(m_state.m_locOfNextLineText).c_str(), msg.str().c_str(),DEBUG);
	aok = false;  //moved here;
      }

    if(isQuarkUnion())
      totalbits = classNode->getMaxBitSizeOfVariableSymbolsInTable(); //data members only
    else
      totalbits = classNode->getBitSizesOfVariableSymbolsInTable(); //data members only

    //check to avoid setting EMPTYSYMBOLTABLE instead of 0 for zero-sized classes
    if(totalbits == CYCLEFLAG)  // was < 0
      {
	std::ostringstream msg;
	msg << "cycle error!! " << m_state.getUlamTypeNameByIndex(getUlamTypeIdx()).c_str();
	    MSG(m_state.getFullLocationAsString(m_state.m_locOfNextLineText).c_str(), msg.str().c_str(),DEBUG);
	    aok = false;
	  }
	else if(totalbits == EMPTYSYMBOLTABLE)
	  {
	    totalbits = 0;
	    aok = true;
	  }
	else if(totalbits != UNKNOWNSIZE)
	  aok = true;  //not UNKNOWN
    return aok;
  } //trySetBitSize


  void SymbolClass::printBitSizeOfClass()
  {
    UTI suti = getUlamTypeIdx();
    u32 total = m_state.getTotalBitSize(suti);
    UlamType * sut = m_state.getUlamTypeByIndex(suti);
    ULAMCLASSTYPE classtype = sut->getUlamClass();

    std::ostringstream msg;
    msg << "[UTBUA] Total bits used/available by " << (classtype == UC_ELEMENT ? "element " : "quark ") << m_state.getUlamTypeNameByIndex(suti).c_str() << " : ";

    if(m_state.isComplete(suti))
      {
	s32 remaining = (classtype == UC_ELEMENT ? (MAXSTATEBITS - total) : (MAXBITSPERQUARK - total));
	msg << total << "/" << remaining;
      }
    else
      {
	total = UNKNOWNSIZE;
	s32 remaining = (classtype == UC_ELEMENT ? MAXSTATEBITS : MAXBITSPERQUARK);
	msg << "UNKNOWN" << "/" << remaining;
      }
    MSG("", msg.str().c_str(),INFO);
  } //printBitSizeOfClass


  void SymbolClass::testThisClass(File * fp)
  {
    NodeBlockClass * classNode = getClassBlockNode();
    assert(classNode);
    m_state.m_classBlock = classNode;
    m_state.m_currentBlock = m_state.m_classBlock;
    m_state.m_compileThisIdx = getUlamTypeIdx();

    if(classNode->findTestFunctionNode())
      {
	// set up an atom in eventWindow; init m_currentObjPtr to point to it
	// set up STACK since func call not called
	m_state.setupCenterSiteForTesting();

	m_state.m_nodeEvalStack.addFrameSlots(1);     //prolog, 1 for return
	s32 rtnValue = 0;
	EvalStatus evs = classNode->eval();
	if(evs != NORMAL)
	  {
	    rtnValue =  -1;   //error!
	  }
	else
	  {
	    UlamValue rtnUV = m_state.m_nodeEvalStack.popArg();
	    rtnValue = rtnUV.getImmediateData(32);
	  }

	//#define CURIOUS_T3146
#ifdef CURIOUS_T3146
	//curious..
	{
	  UlamValue objUV = m_state.m_eventWindow.loadAtomFromSite(c0.convertCoordToIndex());
	  u32 data = objUV.getData(25,32);  //Int f.m_i (t3146)
	  std::ostringstream msg;
	  msg << "Output for m_i = <" << data << "> (expecting 4 for t3146)";
	  MSG("",msg.str().c_str() , INFO);
	}
#endif

	m_state.m_nodeEvalStack.returnFrame();       //epilog

	fp->write("Exit status: " );    //in compared answer
	fp->write_decimal(rtnValue);
	fp->write("\n");
      } //test eval
  }//testClass

  void SymbolClass::cloneConstantExpressionSubtreesByUTI(UTI olduti, UTI newuti, const Resolver& templateRslvr)
  {
    assert(m_resolver);
    m_resolver->cloneConstantExpressionSubtreesByUTI(olduti, newuti, templateRslvr);
  }

  void SymbolClass::cloneNamedConstantExpressionSubtrees(const Resolver &templateRslvr)
  {
    assert(m_resolver);
    m_resolver->cloneNamedConstantExpressionSubtrees(templateRslvr);
  }

  bool SymbolClass::statusUnknownConstantExpressions()
  {
    if(!m_resolver)
      return isDeep();
    return m_resolver->statusUnknownConstantExpressions();
  }

  bool SymbolClass::statusNonreadyClassArguments()
  {
    if(!m_resolver) //shallow clone only!
      return true;
    return m_resolver->statusNonreadyClassArguments();
  }

  void SymbolClass::constantFoldIncompleteUTI(UTI auti)
  {
    if(!m_resolver)
      return; //nothing to do
    m_resolver->constantFoldIncompleteUTI(auti);
  }

  void SymbolClass::linkConstantExpression(UTI uti, NodeTypeBitsize * ceNode)
  {
    if(!m_resolver)
      m_resolver = new Resolver(getUlamTypeIdx(), m_state);
    //assert(m_deep);
    m_resolver->linkConstantExpression(uti, ceNode);
  }

  void SymbolClass::linkConstantExpression(UTI uti, NodeSquareBracket * ceNode)
  {
    if(!m_resolver)
      m_resolver = new Resolver(getUlamTypeIdx(), m_state);
    //assert(m_deep);
    m_resolver->linkConstantExpression(uti, ceNode);
  }

  void SymbolClass::linkConstantExpression(NodeConstantDef * ceNode)
  {
    if(!m_resolver)
      m_resolver = new Resolver(getUlamTypeIdx(), m_state);
    //assert(m_deep);
    m_resolver->linkConstantExpression(ceNode);
  }

  void SymbolClass::linkConstantExpressionForPendingArg(NodeConstantDef * constNode)
  {
    if(!m_resolver) //shallow clone only!
      m_resolver = new Resolver(getUlamTypeIdx(), m_state);
    assert(!m_deep);
    m_resolver->linkConstantExpressionForPendingArg(constNode);
  }

  bool SymbolClass::pendingClassArgumentsForClassInstance()
  {
    if(!m_resolver) //shallow clone only!
      return false; //ok, none pending
    return m_resolver->pendingClassArgumentsForClassInstance();
  }

  /////////////////////////////////////////////////////////////////////////////////
  // from NodeProgram
  /////////////////////////////////////////////////////////////////////////////////

  void SymbolClass::generateCode(FileManager * fm)
  {
    assert(m_classBlock);
    m_state.m_classBlock = m_classBlock;
    m_state.m_currentBlock = m_state.m_classBlock;

    // setup for codeGen
    m_state.m_currentSelfSymbolForCodeGen = this;
    m_state.m_currentObjSymbolsForCodeGen.clear();

    m_state.setupCenterSiteForTesting();  //temporary!!!

    // mangled types and forward class declarations
    genMangledTypesHeaderFile(fm);

    // this class header
    {
      File * fp = fm->open(m_state.getFileNameForThisClassHeader(WSUBDIR).c_str(), WRITE);
      assert(fp);

      generateHeaderPreamble(fp);
      genAllCapsIfndefForHeaderFile(fp);
      generateHeaderIncludes(fp);

      UlamValue uvpass;
      m_classBlock->genCode(fp, uvpass);      //compileThisId only, class block

      // include this .tcc
      m_state.indent(fp);
      fp->write("#include \"");
      fp->write(m_state.getFileNameForThisClassBody().c_str());
      fp->write("\"\n\n");

      // include native .tcc for this class if any declared
      if(m_classBlock->countNativeFuncDecls() > 0)
	{
	  m_state.indent(fp);
	  fp->write("#include \"");
	  fp->write(m_state.getFileNameForThisClassBodyNative().c_str());
	  fp->write("\"\n\n");
	}

      genAllCapsEndifForHeaderFile(fp);

      delete fp; //close
    }

    // this class body
    {
      File * fp = fm->open(m_state.getFileNameForThisClassBody(WSUBDIR).c_str(), WRITE);
      assert(fp);

      m_state.m_currentIndentLevel = 0;
      fp->write(CModeForHeaderFiles);  //needed for .tcc files too

      UlamValue uvpass;
      m_classBlock->genCodeBody(fp, uvpass);  //compileThisId only, MFM namespace

      delete fp;  //close
    }

    // "stub" .cpp includes .h (unlike the .tcc body)
    {
      File * fp = fm->open(m_state.getFileNameForThisClassCPP(WSUBDIR).c_str(), WRITE);
      assert(fp);

      m_state.m_currentIndentLevel = 0;

      // include .h in the .cpp
      m_state.indent(fp);
      fp->write("#include \"");
      fp->write(m_state.getFileNameForThisClassHeader().c_str());
      fp->write("\"\n");
      fp->write("\n");

      delete fp; //close
    }

    //separate main.cpp for elements only; that have the test method.
    //if(m_state.getUlamTypeByIndex(m_classBlock->getNodeType())->getUlamClass() == UC_ELEMENT)
    if(m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamClass() == UC_ELEMENT)
      {
	if(m_state.thisClassHasTheTestMethod())
	  generateMain(fm);
      }
  } //generateCode

  void SymbolClass::generateAsOtherInclude(File * fp)
  {
    UTI suti = getUlamTypeIdx();
    if(suti != m_state.m_compileThisIdx)
      {
	m_state.indent(fp);
	fp->write("#include \"");
	fp->write(m_state.getFileNameForAClassHeader(suti).c_str());
	fp->write("\"\n");
      }
  } //generateAsOtherInclude

  void SymbolClass::generateAsOtherForwardDef(File * fp)
  {
    UTI suti = getUlamTypeIdx();
    if(suti != m_state.m_compileThisIdx)
      {
	UlamType * sut = m_state.getUlamTypeByIndex(suti);
	ULAMCLASSTYPE sclasstype = sut->getUlamClass();

	m_state.indent(fp);
	fp->write("namespace MFM { template ");
	if(sclasstype == UC_QUARK)
	  fp->write("<class CC, u32 POS> ");
	else if(sclasstype == UC_ELEMENT)
	  fp->write("<class CC> ");
	else
	  assert(0);

	fp->write("struct ");
	fp->write(sut->getUlamTypeMangledName().c_str());
	fp->write("; }  //FORWARD\n");
      }
  } //generateAsOtherForwardDef

  void SymbolClass::generateTestInstance(File * fp, bool runtest)
  {
    std::ostringstream runThisTest;
    UTI suti = getUlamTypeIdx();
    UlamType * sut = m_state.getUlamTypeByIndex(suti);

    SymbolClassName * cnsym = m_parentTemplate;
    assert(cnsym);
    std::string tail = cnsym->formatAnInstancesArgValuesAsAString(suti);
    std::ostringstream namestr;
    namestr << m_state.m_pool.getDataAsString(getId()) << tail;

    std::string lowercasename = firstletterTolowercase(namestr.str());
    std::ostringstream ourname;
    ourname << "Our" << namestr.str();

    if(!runtest)
      {
	fp->write("\n");
	// only for elements, as restricted by caller
	m_state.indent(fp);
	fp->write("typedef ");
	fp->write("MFM::");
	fp->write(sut->getUlamTypeMangledName().c_str());

	fp->write("<OurCoreConfig> ");
	fp->write(ourname.str().c_str());
	fp->write(";\n");

	m_state.indent(fp);
	fp->write(ourname.str().c_str());
	fp->write("& ");
	fp->write(lowercasename.c_str());
	fp->write(" = ");
	fp->write(ourname.str().c_str());
	fp->write("::THE_INSTANCE;\n");

	m_state.indent(fp);
	fp->write(lowercasename.c_str());
	fp->write(".AllocateType();  // Force element type allocation now\n");
	m_state.indent(fp);
	fp->write("theTile.RegisterElement(");
	fp->write(lowercasename.c_str());
	fp->write(");\n");
      }
    else
      {
	if(getId() == m_state.m_compileThisId)
	  {
	    fp->write("\n");
	    m_state.indent(fp);
	    fp->write("OurAtom ");
	    fp->write(lowercasename.c_str());
	    fp->write("Atom = ");
	    fp->write(lowercasename.c_str());
	    fp->write(".GetDefaultAtom();\n");

	    runThisTest << lowercasename.c_str() << ".Uf_4test(" << "uc, " << lowercasename.c_str() << "Atom)";

	    m_state.indent(fp);
	    fp->write("rtn = ");
	    fp->write(runThisTest.str().c_str()); //uses hardcoded mangled test name
	    fp->write(";\n");

	    m_state.indent(fp);
	    fp->write("//return rtn.read();\n"); //was useful to return result of test
	    m_state.indent(fp);
	    fp->write("//std::cerr << rtn.read() << std::endl;\n"); //useful to return result of test?
	  }
      }
  } //generateTestInstance

  void SymbolClass::generateHeaderPreamble(File * fp)
  {
    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);
    fp->write("/***********************         DO NOT EDIT        ******************************\n");
    fp->write("*\n");
    fp->write("* ");
    fp->write(m_state.m_pool.getDataAsString(m_state.m_compileThisId).c_str());
    fp->write(".h - ");
    //ULAMCLASSTYPE classtype = m_state.getUlamTypeByIndex(m_classBlock->getNodeType())->getUlamClass();
    ULAMCLASSTYPE classtype = m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamClass();
    if(classtype == UC_ELEMENT)
      fp->write("Element");
    else if(classtype == UC_QUARK)
      fp->write("Quark");
    else
      assert(0);

    fp->write(" header for ULAM\n");

    fp->write(CopyrightAndLicenseForUlamHeader);
  } //generateHeaderPreamble


  void SymbolClass::genAllCapsIfndefForHeaderFile(File * fp)
  {
    //UlamType * cut = m_state.getUlamTypeByIndex(m_classBlock->getNodeType());
    UlamType * cut = m_state.getUlamTypeByIndex(getUlamTypeIdx());
    m_state.indent(fp);
    fp->write("#ifndef ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName().c_str()).c_str());
    fp->write("_H\n");

    m_state.indent(fp);
    fp->write("#define ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName().c_str()).c_str());
    fp->write("_H\n\n");
  } //genAllCapsIfndefForHeaderFile


  void SymbolClass::genAllCapsEndifForHeaderFile(File * fp)
  {
    //UlamType * cut = m_state.getUlamTypeByIndex(m_classBlock->getNodeType());
    UlamType * cut = m_state.getUlamTypeByIndex(getUlamTypeIdx());
    fp->write("#endif //");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName().c_str()).c_str());
    fp->write("_H\n");
  }

  void SymbolClass::generateHeaderIncludes(File * fp)
  {
    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    //using the _Types.h file
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisTypesHeader().c_str());
    fp->write("\"\n");
    fp->write("\n");

    //generate includes for all the other classes that have appeared
    m_state.m_programDefST.generateForwardDefsForTableOfClasses(fp);
  } //generateHeaderIncludes

  // create structs with BV, as storage, and typedef
  // for primitive types; useful as args and local variables;
  // important for overloading functions
  void SymbolClass::genMangledTypesHeaderFile(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisTypesHeader(WSUBDIR).c_str(), WRITE);
    assert(fp);

    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);

    m_state.indent(fp);
    //use -I ../../../include in g++ command
    fp->write("//#include \"itype.h\"\n");
    fp->write("//#include \"BitVector.h\"\n");
    fp->write("//#include \"BitField.h\"\n");
    fp->write("\n");

    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    // do primitive types before classes so that immediate
    // Quarks/Elements can use them (e.g. immediate index for aref)

    std::map<UlamKeyTypeSignature, UlamType *, less_than_key>::iterator it = m_state.m_definedUlamTypes.begin();
    while(it != m_state.m_definedUlamTypes.end())
      {
	UlamType * ut = it->second;
	if(ut->needsImmediateType() && ut->getUlamClass() == UC_NOTACLASS)   //e.g. skip constants, incl atom
	  ut->genUlamTypeMangledDefinitionForC(fp);
	it++;
      }

    //same except now for user defined Class types
    it = m_state.m_definedUlamTypes.begin();
    while(it != m_state.m_definedUlamTypes.end())
      {
	UlamType * ut = it->second;
	ULAMCLASSTYPE classtype = ut->getUlamClass();
	if(ut->needsImmediateType() && classtype != UC_NOTACLASS)
	  {
	    ut->genUlamTypeMangledDefinitionForC(fp);
	    if(classtype == UC_QUARK)
	      ut->genUlamTypeMangledAutoDefinitionForC(fp);
	  }
	it++;
      }
    delete fp; //close
  } //genMangledTypeHeaderFile

  // append main to .cpp for debug useage
  // outside the MFM namespace !!!
  void SymbolClass::generateMain(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisClassMain(WSUBDIR).c_str(), WRITE);
    assert(fp);

    m_state.m_currentIndentLevel = 0;

    m_state.indent(fp);
    fp->write("#include <stdio.h>\n");
    m_state.indent(fp);
    fp->write("#include <iostream>\n\n"); //to cout/cerr rtn

    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    m_state.indent(fp);
    fp->write("//includes Element.h\n");
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisClassHeader().c_str());
    fp->write("\"\n");

    m_state.m_programDefST.generateIncludesForTableOfClasses(fp); //the other classes

    //MAIN STARTS HERE !!!
    fp->write("\n");
    m_state.indent(fp);
    fp->write("int main()\n");

    m_state.indent(fp);
    fp->write("{\n");

    m_state.m_currentIndentLevel++;

    m_state.indent(fp);
    fp->write("enum { SIZE = ");
    fp->write_decimal(BITSPERATOM);
    fp->write(" };\n");

    m_state.indent(fp);
    fp->write("typedef MFM::ParamConfig<SIZE> OurParamConfig;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::P3Atom<OurParamConfig> OurAtom;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::CoreConfig<OurAtom, OurParamConfig> OurCoreConfig;\n");
    m_state.indent(fp);
    fp->write("typedef MFM::UlamContext<OurCoreConfig> OurUlamContext;\n");
    m_state.indent(fp);
    fp->write("typedef MFM::Tile<OurCoreConfig> OurTile;\n");
    m_state.indent(fp);
    fp->write("OurTile theTile;\n");

    m_state.indent(fp);
    fp->write("OurUlamContext uc;\n");
    m_state.indent(fp);
    fp->write("uc.SetTile(theTile);\n");

    m_state.indent(fp);
    fp->write("MFM::Ui_Ut_102323Int rtn;\n");

    m_state.m_programDefST.generateTestInstancesForTableOfClasses(fp);

    m_state.indent(fp);
    fp->write("return 0;\n");

    m_state.m_currentIndentLevel--;
    m_state.indent(fp);
    fp->write("} //main \n");

    delete fp; //close
  } //generateMain

  std::string SymbolClass::firstletterTolowercase(const std::string s) //static method
  {
    std::ostringstream up;
    assert(!s.empty());
    std::string c(1,(s[0] >= 'A' && s[0] <= 'Z') ? s[0]-('A'-'a') : s[0]);
    up << c << s.substr(1,s.length());
    return up.str();
  } //firstletterTolowercase

} //end MFM
