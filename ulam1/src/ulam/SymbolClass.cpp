#include <sstream>
#include <string.h>
#include "CompilerState.h"
#include "SymbolClass.h"

namespace MFM {

  static const char * CModeForHeaderFiles = "/**                                      -*- mode:C++ -*- */\n\n";

  // First line something like: "/* NodeProgram.h - Root Node of Programs for ULAM\n"
  static const char * CopyrightAndLicenseForUlamHeader =   "*\n"
    "**********************************************************************************\n"
    "* This code is generated by the ULAM programming language compilation system.\n"
    "*\n"
    "* The ULAM programming language compilation system is free software:\n"
    "* you can redistribute it and/or modify it under the terms of the GNU\n"
    "* General Public License as published by the Free Software\n"
    "* Foundation, either version 3 of the License, or (at your option)\n"
    "* any later version.\n"
    "*\n"
    "* The ULAM programming language compilation system is distributed in\n"
    "* the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n"
    "* even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n"
    "* PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
    "* details.\n"
    "*\n"
    "* You should have received a copy of the GNU General Public License\n"
    "* along with the ULAM programming language compilation system\n"
    "* software.  If not, see <http://www.gnu.org/licenses/>.\n"
    "*\n"
    "* @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n"
    "*/\n\n";

  SymbolClass::SymbolClass(u32 id, UTI utype, NodeBlockClass * classblock, CompilerState& state) : Symbol(id, utype, state), m_classBlock(classblock), m_quarkunion(false){}

  SymbolClass::~SymbolClass()
  {
    delete m_classBlock;
    m_classBlock = NULL;
  }


  void SymbolClass::setClassBlockNode(NodeBlockClass * node)
  {
    m_classBlock = node;
  }


  NodeBlockClass * SymbolClass::getClassBlockNode()
  {
    return m_classBlock;
  }


  bool SymbolClass::isClass()
  {
    return true;
  }


  const std::string SymbolClass::getMangledPrefix()
  {
    return m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamTypeUPrefix();
  }


  ULAMCLASSTYPE SymbolClass::getUlamClass()
  {
    return  m_state.getUlamTypeByIndex(getUlamTypeIdx())->getUlamClass();
  }


  void SymbolClass::setUlamClass(ULAMCLASSTYPE type)
  {
    ((UlamTypeClass * ) m_state.getUlamTypeByIndex(getUlamTypeIdx()))->setUlamClass(type);
  }

  void SymbolClass::setQuarkUnion()
  {
    m_quarkunion = true;
  }

  bool SymbolClass::isQuarkUnion()
  {
    return m_quarkunion;
  }



  /////////////////////////////////////////////////////////////////////////////////
  // from NodeProgram
  /////////////////////////////////////////////////////////////////////////////////

  void SymbolClass::generateCode(FileManager * fm)
  {
    assert(m_classBlock);
    m_state.m_classBlock = m_classBlock;
    m_state.m_currentBlock = m_state.m_classBlock;

    // setup for codeGen
    m_state.m_currentSelfSymbolForCodeGen = this;
    m_state.m_currentObjSymbolsForCodeGen.clear();

    m_state.setupCenterSiteForTesting();  //temporary!!!

    // mangled types and forward class declarations
    genMangledTypesHeaderFile(fm);

    // this class header
    {
      File * fp = fm->open(m_state.getFileNameForThisClassHeader(WSUBDIR).c_str(), WRITE);
      assert(fp);

      generateHeaderPreamble(fp);
      genAllCapsIfndefForHeaderFile(fp);
      generateHeaderIncludes(fp);

      UlamValue uvpass;
      m_classBlock->genCode(fp, uvpass);      //compileThisId only, class block

      // include this .tcc
      m_state.indent(fp);
      fp->write("#include \"");
      fp->write(m_state.getFileNameForThisClassBody().c_str());
      fp->write("\"\n\n");

      // include native .tcc for this class if any declared
      if(m_classBlock->countNativeFuncDecls() > 0)
	{
	  m_state.indent(fp);
	  fp->write("#include \"");
	  fp->write(m_state.getFileNameForThisClassBodyNative().c_str());
	  fp->write("\"\n\n");
	}

      genAllCapsEndifForHeaderFile(fp);

      delete fp; //close
    }

    // this class body
    {
      File * fp = fm->open(m_state.getFileNameForThisClassBody(WSUBDIR).c_str(), WRITE);
      assert(fp);

      m_state.m_currentIndentLevel = 0;
      fp->write(CModeForHeaderFiles);  //needed for .tcc files too

      UlamValue uvpass;
      m_classBlock->genCodeBody(fp, uvpass);  //compileThisId only, MFM namespace

      delete fp;  //close
    }

    // "stub" .cpp includes .h (unlike the .tcc body)
    {
      File * fp = fm->open(m_state.getFileNameForThisClassCPP(WSUBDIR).c_str(), WRITE);
      assert(fp);

      m_state.m_currentIndentLevel = 0;

      // include .h in the .cpp
      m_state.indent(fp);
      fp->write("#include \"");
      fp->write(m_state.getFileNameForThisClassHeader().c_str());
      fp->write("\"\n");
      fp->write("\n");

      delete fp; //close
    }

    //separate main.cpp for elements only; that have the test method.
    if(m_state.getUlamTypeByIndex(m_classBlock->getNodeType())->getUlamClass() == UC_ELEMENT)
      {
	if(m_state.thisClassHasTheTestMethod())
	  generateMain(fm);
      }
  } //generateCode


  void SymbolClass::generateHeaderPreamble(File * fp)
  {
    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);
    fp->write("/***********************         DO NOT EDIT        ******************************\n");
    fp->write("*\n");
    fp->write("* ");
    fp->write(m_state.m_pool.getDataAsString(m_state.m_compileThisId).c_str());
    fp->write(".h - ");
    ULAMCLASSTYPE classtype = m_state.getUlamTypeByIndex(m_classBlock->getNodeType())->getUlamClass();
    if(classtype == UC_ELEMENT)
      fp->write("Element");
    else if(classtype == UC_QUARK)
      fp->write("Quark");
    else
      assert(0);

    fp->write(" header for ULAM\n");

    fp->write(CopyrightAndLicenseForUlamHeader);
  } //generateHeaderPreamble


  void SymbolClass::genAllCapsIfndefForHeaderFile(File * fp)
  {
    UlamType * cut = m_state.getUlamTypeByIndex(m_classBlock->getNodeType());
    m_state.indent(fp);
    fp->write("#ifndef ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n");

    m_state.indent(fp);
    fp->write("#define ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n\n");
  } //genAllCapsIfndefForHeaderFile


  void SymbolClass::genAllCapsEndifForHeaderFile(File * fp)
  {
    UlamType * cut = m_state.getUlamTypeByIndex(m_classBlock->getNodeType());
    fp->write("#endif //");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n");
  }


  void SymbolClass::generateHeaderIncludes(File * fp)
  {
    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    //using the _Types.h file
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisTypesHeader().c_str());
    fp->write("\"\n");
    fp->write("\n");

    //generate includes for all the other classes that have appeared
    m_state.m_programDefST.generateForwardDefsForTableOfClasses(fp);
  } //generateHeaderIncludes


  // create structs with BV, as storage, and typedef
  // for primitive types; useful as args and local variables;
  // important for overloading functions
  void SymbolClass::genMangledTypesHeaderFile(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisTypesHeader(WSUBDIR).c_str(), WRITE);
    assert(fp);

    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);

    m_state.indent(fp);
    //use -I ../../../include in g++ command
    fp->write("//#include \"itype.h\"\n");
    fp->write("//#include \"BitVector.h\"\n");
    fp->write("//#include \"BitField.h\"\n");
    fp->write("\n");

    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    // do primitive types before classes so that immediate
    // Quarks/Elements can use them (e.g. immediate index for aref)

    std::map<UlamKeyTypeSignature, UlamType *, less_than_key>::iterator it = m_state.m_definedUlamTypes.begin();
    while(it != m_state.m_definedUlamTypes.end())
      {
	UlamType * ut = it->second;
	if(ut->needsImmediateType() && ut->getUlamClass() == UC_NOTACLASS)   //e.g. skip constants, incl atom
	  ut->genUlamTypeMangledDefinitionForC(fp, &m_state);
	it++;
      }

    //same except now for user defined Class types
    it = m_state.m_definedUlamTypes.begin();
    while(it != m_state.m_definedUlamTypes.end())
      {
	UlamType * ut = it->second;
	ULAMCLASSTYPE classtype = ut->getUlamClass();
	if(ut->needsImmediateType() && classtype != UC_NOTACLASS)
	  {
	    ut->genUlamTypeMangledDefinitionForC(fp, &m_state);
	    if(classtype == UC_QUARK)
	      ut->genUlamTypeMangledAutoDefinitionForC(fp, &m_state);
	  }
	it++;
      }
    delete fp; //close
  } //genMangledTypeHeaderFile


  // append main to .cpp for debug useage
  // outside the MFM namespace !!!
  void SymbolClass::generateMain(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisClassMain(WSUBDIR).c_str(), WRITE);
    assert(fp);

    m_state.m_currentIndentLevel = 0;

    m_state.indent(fp);
    fp->write("#include <stdio.h>\n\n");

    m_state.indent(fp);
    fp->write("#include \"UlamDefs.h\"\n\n");

    m_state.indent(fp);
    fp->write("//includes Element.h\n");
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisClassHeader().c_str());
    fp->write("\"\n");

    m_state.m_programDefST.generateIncludesForTableOfClasses(fp); //the other classes

    //MAIN STARTS HERE !!!
    fp->write("\n");
    m_state.indent(fp);
    fp->write("int main()\n");

    m_state.indent(fp);
    fp->write("{\n");

    m_state.m_currentIndentLevel++;

    m_state.indent(fp);
    fp->write("enum { SIZE = ");
    fp->write_decimal(BITSPERATOM);
    fp->write(" };\n");

    m_state.indent(fp);
    fp->write("typedef MFM::ParamConfig<SIZE> OurParamConfig;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::P3Atom<OurParamConfig> OurAtom;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::CoreConfig<OurAtom, OurParamConfig> OurCoreConfig;\n");
    m_state.indent(fp);
    fp->write("typedef MFM::UlamContext<OurCoreConfig> OurUlamContext;\n");
    m_state.indent(fp);
    fp->write("typedef MFM::Tile<OurCoreConfig> OurTile;\n");
    m_state.indent(fp);
    fp->write("OurTile theTile;\n");

    m_state.indent(fp);
    fp->write("OurUlamContext uc;\n");
    m_state.indent(fp);
    fp->write("uc.SetTile(theTile);\n");

    //declare an instance of all element classes; supports immediate types constructors
    std::string runThisTest = m_state.m_programDefST.generateTestInstancesForTableOfClasses(fp);

    m_state.indent(fp);
    fp->write("MFM::Ui_Ut_102323Int rtn;\n");

    m_state.indent(fp);
    fp->write("rtn = ");
    fp->write(runThisTest.c_str());  //uses hardcoded mangled test name
    fp->write(";\n");

#if 0
    // output for t3200 (before System native), compile gen code & run: ./main
    m_state.indent(fp);
    fp->write("printf(\"Bar1 toInt = %d\\n\", OurFoo::Ut_Um_4bar1::Uf_5toInt(uc, fooAtom).read());\n");
    m_state.indent(fp);
    fp->write("printf(\"Bar2 toInt = %d\\n\", OurFoo::Ut_Um_4bar2::Uf_5toInt(uc, fooAtom).read());\n");
    //Int(4) maxes out at 7, not 12.
#endif

    m_state.indent(fp);
    //fp->write("return 0;\n");
    fp->write("return rtn.read();\n");         // useful to return result of test

    m_state.m_currentIndentLevel--;

    m_state.indent(fp);
    fp->write("}\n");
    delete fp; //close
  } //generateMain



} //end MFM
