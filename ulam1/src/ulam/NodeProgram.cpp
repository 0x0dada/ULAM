#include <stdio.h>
#include <map>

#include "NodeProgram.h"
#include "CompilerState.h"

namespace MFM {

  static const char * CModeForHeaderFiles = "/**                                      -*- mode:C++ -*- */\n\n";

  // First line something like: "/* NodeProgram.h - Root Node of Programs for ULAM\n"
  static const char * CopyrightAndLicenseForUlamHeader =   "*\n"
    "**********************************************************************************\n"
    "* This code is generated by the ULAM programming language compilation system.\n"
    "*\n"
    "* The ULAM programming language compilation system is free software:\n"
    "* you can redistribute it and/or modify it under the terms of the GNU\n"
    "* General Public License as published by the Free Software\n"
    "* Foundation, either version 3 of the License, or (at your option)\n"
    "* any later version.\n"
    "*\n"
    "* The ULAM programming language compilation system is distributed in\n"
    "* the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n"
    "* even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n"
    "* PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
    "* details.\n"
    "*\n"
    "* You should have received a copy of the GNU General Public License\n"
    "* along with the ULAM programming language compilation system\n"
    "* software.  If not, see <http://www.gnu.org/licenses/>.\n"
    "*\n"
    "* @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n"
    "*/\n\n";
  
  NodeProgram::NodeProgram(u32 id, CompilerState & state) : Node(state), m_root(NULL), m_compileThisId(id) {}

  NodeProgram::~NodeProgram()
  {
    //m_root deletion handled by m_programDefST;
  }


  void NodeProgram::setRootNode(NodeBlockClass * root)
  {
    m_root = root;
  }


  void NodeProgram::print(File * fp)
  {
    printNodeLocation(fp);
    UTI myut = getNodeType();
    char id[255];
    if(myut == Nav)
      sprintf(id,"%s<NOTYPE>\n", prettyNodeName().c_str());
    else
      sprintf(id,"%s<%s>\n", prettyNodeName().c_str(), m_state.getUlamTypeNameByIndex(myut).c_str());
    fp->write(id);

    //overrides NodeBlock print, has m_root, no m_node or m_nextNode.
    if(m_root)
      m_root->print(fp);
    else 
      fp->write("<NULL>\n");

    sprintf(id,"-----------------%s\n", prettyNodeName().c_str());
    fp->write(id);
  }


  void NodeProgram::printPostfix(File * fp)
  {
    m_state.m_classBlock = m_root;  //reset to compileThis' class block
    m_state.m_currentBlock = m_state.m_classBlock;

    if(m_root)
	m_root->printPostfix(fp);
    else 
      fp->write("<NULL>\n");
  }


  const char * NodeProgram::getName()
  {
    return  m_state.m_pool.getDataAsString(m_compileThisId).c_str();
  }


  const std::string NodeProgram::prettyNodeName()
  {
    return nodeName(__PRETTY_FUNCTION__);
  }

#define MAX_ITERATIONS 10
  UTI NodeProgram::checkAndLabelType()
  { 
    assert(m_root);
    m_state.m_err.clearCounts();

    // label all the class; sets "current" m_currentClassSymbol in CS
    m_state.m_programDefST.labelTableOfClasses();

    if(m_state.m_err.getErrorCount() == 0)
      {
	u32 infcounter = 0;
	// size all the class; sets "current" m_currentClassSymbol in CS
	while(!m_state.m_programDefST.setBitSizeOfTableOfClasses())
	  {	    
	    if(++infcounter > MAX_ITERATIONS)
	      {
		std::ostringstream msg;
		msg << "Possible empty class found during type labeling, of class <";
		msg << m_state.m_pool.getDataAsString(m_state.m_compileThisId);
		msg << ">, proceed with caution.";
		MSG(getNodeLocationAsString().c_str(), msg.str().c_str(), INFO);
		
		break;
	      }
	  }
	// must happen after type labeling and before code gen; separate pass.
	m_state.m_programDefST.packBitsForTableOfClasses();

	// let Ulam programmer know the bits used/available
	//m_state.m_programDefST.printBitSizeOfTableOfClasses();
      }

    UTI rtnType =  m_root->getNodeType();
    setNodeType(rtnType);   //void type. missing?

    // reset m_current class block, for next stage
    m_state.m_classBlock = m_root;  //reset to compileThis' class block
    m_state.m_currentBlock = m_state.m_classBlock;

    u32 warns = m_state.m_err.getWarningCount();
    if(warns > 0)
      {
	std::ostringstream msg;
	msg << warns << " warnings during type labeling";
	MSG(getNodeLocationAsString().c_str(), msg.str().c_str(), INFO);
      }

    u32 errs = m_state.m_err.getErrorCount();
    if(errs > 0)
      {
	std::ostringstream msg;
	msg << errs << " TOO MANY TYPELABEL ERRORS";
	MSG(getNodeLocationAsString().c_str(), msg.str().c_str(), INFO);
      }

    return rtnType;
  }


   EvalStatus NodeProgram::eval()
  {
    assert(m_root);
    m_state.m_err.clearCounts();

    m_state.m_classBlock = m_root;  //reset to compileThis' class block
    m_state.m_currentBlock = m_state.m_classBlock;

    setNodeType(Int);     //for testing

    evalNodeProlog(1);    //new current frame pointer for nodeeval stack
    EvalStatus evs = m_root->eval();

    // output informational warning and error counts
    u32 warns = m_state.m_err.getWarningCount();
    if(warns > 0)
      {
	std::ostringstream msg;
	msg << warns << " warnings during eval";
	MSG(getNodeLocationAsString().c_str(), msg.str().c_str(), INFO);
      }

    u32 errs = m_state.m_err.getErrorCount();
    if(errs > 0)
      {
	std::ostringstream msg;
	msg << errs << " TOO MANY EVAL ERRORS";
	MSG(getNodeLocationAsString().c_str(), msg.str().c_str(), INFO);
      }

    if(evs == NORMAL)
      {
	UlamValue testUV = m_state.m_nodeEvalStack.popArg();
	assignReturnValueToStack(testUV);     //for testProgram in Compiler
      }

    evalNodeEpilog();
    return evs;
  }


  void NodeProgram::generateCode(FileManager * fm)
    {
      assert(m_root);
      m_state.m_err.clearCounts();

      m_state.m_classBlock = m_root;  //reset to compileThis' class block
      m_state.m_currentBlock = m_state.m_classBlock;

      // mangled types and forward class declarations
      genMangledTypeHeaderFile(fm);    

      // this class header
      {
	File * fp = fm->open(m_state.getFileNameForThisClassHeader().c_str(), WRITE);
	assert(fp);

	generateHeaderPreamble(fp);
	genAllCapsIfndefForHeaderFile(fp);
	generateHeaderIncludes(fp);

	UlamValue uvpass;
	m_root->genCode(fp, uvpass);      //compileThisId only, class block

	// include this .tcc
	m_state.indent(fp);
	fp->write("#include \"");
	fp->write(m_state.getFileNameForThisClassBody().c_str());
	fp->write("\"\n\n");

	// include native .tcc for this class if any declared
	if(m_root->countNativeFuncDecls() > 0)
	  {
	    m_state.indent(fp);
	    fp->write("#include \"");
	    fp->write(m_state.getFileNameForThisClassBodyNative().c_str());
	    fp->write("\"\n\n");
	  }

	genAllCapsEndifForHeaderFile(fp);

	delete fp;
      }

      // this class body
      {
	File * fp = fm->open(m_state.getFileNameForThisClassBody().c_str(), WRITE);
	assert(fp);

	m_state.m_currentIndentLevel = 0;
	fp->write(CModeForHeaderFiles);  //needed for .tcc files too
 
	UlamValue uvpass;
	m_root->genCodeBody(fp, uvpass);  //compileThisId only, MFM namespace

	delete fp;
      }

      // "stub" .cpp includes .h (unlike the .tcc body)
      {
	File * fp = fm->open(m_state.getFileNameForThisClassCPP().c_str(), WRITE);
	assert(fp);

	m_state.m_currentIndentLevel = 0;
	
	// include .h in the .cpp
	m_state.indent(fp);
	fp->write("#include \"");
	fp->write(m_state.getFileNameForThisClassHeader().c_str());  
	fp->write("\"\n");
	fp->write("\n");

	delete fp;
      }

      //separate main.cpp for elements only
      if(m_state.getUlamTypeByIndex(m_root->getNodeType())->getUlamClass() == UC_ELEMENT)
	{
	  generateMain(fm);  	  
	}

    }  //generateCode


  void NodeProgram::generateHeaderPreamble(File * fp)
  {
    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);
    fp->write("/***********************         DO NOT EDIT        ******************************\n");
    fp->write("*\n");
    fp->write("* ");
    fp->write(m_state.m_pool.getDataAsString(m_state.m_compileThisId).c_str());
    fp->write(".h - ");
    ULAMCLASSTYPE classtype = m_state.getUlamTypeByIndex(m_root->getNodeType())->getUlamClass();
    if(classtype == UC_ELEMENT)
      fp->write("Element");
    else if(classtype == UC_QUARK)
      fp->write("Quark");
    else
      assert(0);

    fp->write(" header for ULAM\n");

    fp->write(CopyrightAndLicenseForUlamHeader);
  }


  void NodeProgram::genAllCapsIfndefForHeaderFile(File * fp)
  {
    UlamType * cut = m_state.getUlamTypeByIndex(m_root->getNodeType());
    m_state.indent(fp);
    fp->write("#ifndef ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n");

    m_state.indent(fp);
    fp->write("#define ");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n\n");
  }


  void NodeProgram::genAllCapsEndifForHeaderFile(File * fp)
  {
    UlamType * cut = m_state.getUlamTypeByIndex(m_root->getNodeType());
    //m_state.indent(fp);
    fp->write("#endif //");
    fp->write(Node::allCAPS(cut->getUlamTypeMangledName(&m_state).c_str()).c_str());
    fp->write("_H\n");
  }


  void NodeProgram::generateHeaderIncludes(File * fp)
  {
    m_state.indent(fp);
#if 0
    // moved to _types.h
    //use -I ../../../include in g++ command
    fp->write("//#include \"itype.h\"\n"); 
    fp->write("//#include \"BitVector.h\"\n"); 
    fp->write("//#include \"BitField.h\"\n"); 
#endif
    fp->write("#include \"EmergentBoilerPlate.h\"\n\n");

    //using the _Types.h file
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisTypesHeader().c_str());  
    fp->write("\"\n");
    fp->write("\n");

    //generate includes for all the other classes that have appeared
    m_state.m_programDefST.generateIncludesForTableOfClasses(fp);
  } //generateHeaderIncludes


#if 0
  // REPLACED BY: genImmediateMangledTypesForHeaderFile
  // this is for immediate types, and will probably be moved to the element's .h
  // since template typedefs are not supported in the version of g++ we've selected.
  void NodeProgram::GENMANGLEDTYPEHEADERFILE(FILEMANAGER * FM)
  {
    FILE * fp = fm->open(m_state.getFileNameForThisTypesHeader().c_str(), WRITE);
    assert(fp);
    
    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);

    m_state.indent(fp);
    //use -I ../../../include in g++ command
    fp->write("//#include \"itype.h\"\n"); 
    fp->write("//#include \"BitVector.h\"\n"); 
    fp->write("//#include \"BitField.h\"\n"); 
    fp->write("\n");

    m_state.indent(fp);
    fp->write("#include \"EmergentBoilerPlate.h\"\n\n");

    //skip Nav type (0)
    u32 numTypes = m_state.m_indexToUlamType.size();
    for(u32 i = 1; i < numTypes; i++)
      {
	UlamType * ut = m_state.getUlamTypeByIndex(i);
	if(!m_state.isConstant(i))   //skip constants
	  ut->genUlamTypeMangledDefinitionForC(fp, &m_state);
      }
    delete fp;
  }
#endif


  //redo: create structs with BV, as storage, and typedef
  //      for primitive types; useful as args and local variables;
  //      important for overloading functions
  void NodeProgram::genMangledTypeHeaderFile(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisTypesHeader().c_str(), WRITE);
    assert(fp);
    
    m_state.m_currentIndentLevel = 0;
    fp->write(CModeForHeaderFiles);

    m_state.indent(fp);
    //use -I ../../../include in g++ command
    fp->write("//#include \"itype.h\"\n"); 
    fp->write("//#include \"BitVector.h\"\n"); 
    fp->write("//#include \"BitField.h\"\n"); 
    fp->write("\n");

    m_state.indent(fp);
    fp->write("#include \"EmergentBoilerPlate.h\"\n\n");

    //skip Nav type (0)
    u32 numTypes = m_state.m_indexToUlamType.size();
    for(u32 i = 1; i < numTypes; i++)
      {
	UlamType * ut = m_state.getUlamTypeByIndex(i);
	if(ut->needsImmediateType())   //e.g. skip constants
	  ut->genUlamTypeMangledDefinitionForC(fp, &m_state);
      }
    delete fp;
  } //genMangledTypeHeaderFile
 

  // append main to .cpp for debug useage
  // outside the MFM namespace !!!
  void NodeProgram::generateMain(FileManager * fm)
  {
    File * fp = fm->open(m_state.getFileNameForThisClassMain().c_str(), WRITE);
    assert(fp);
    
    m_state.m_currentIndentLevel = 0;
    
    m_state.indent(fp);
    fp->write("#include <stdio.h>\n\n");


    m_state.indent(fp);
    fp->write("#include \"EmergentBoilerPlate.h\"\n\n");

#if 0
    m_state.indent(fp);
    fp->write("#include \"Atom.h\"\n\n");

    m_state.indent(fp);
    fp->write("//CoreConfig.h\n");
    m_state.indent(fp);
    fp->write("template <class A, class P>\n");
    m_state.indent(fp);
    fp->write("struct CoreConfig\n");
    m_state.indent(fp);
    fp->write("{\n");
    m_state.m_currentIndentLevel++;
    m_state.indent(fp);
    fp->write("typedef A ATOM_TYPE;\n");
    m_state.indent(fp);
    fp->write("typedef A PARAM_CONFIG;\n");
    m_state.m_currentIndentLevel--;
    m_state.indent(fp);
    fp->write("};\n\n");

    m_state.indent(fp);
    fp->write("//ParamConfig.h\n");
    m_state.indent(fp);
    fp->write("template <u32 BPA>\n");
    m_state.indent(fp);
    fp->write("struct ParamConfig\n");
    m_state.indent(fp);
    fp->write("{\n");
    m_state.m_currentIndentLevel++;
    m_state.indent(fp);
    fp->write("enum { BITS_PER_ATOM = BPA };\n");
    m_state.m_currentIndentLevel--;
    m_state.indent(fp);
    fp->write("};\n\n");


    m_state.indent(fp);
    fp->write("//P3Atom.h\n");
    m_state.indent(fp);
    fp->write("template <class PC>\n");
    m_state.indent(fp);
    fp->write("struct P3Atom : Atom<CoreConfig <P3Atom<PC>, PC> > {\n");
    m_state.indent(fp);
    fp->write("};\n");
    fp->write("\n");
#endif

    m_state.indent(fp);
    fp->write("//includes Element.h\n");
    m_state.indent(fp);
    fp->write("#include \"");
    fp->write(m_state.getFileNameForThisClassHeader().c_str());
    fp->write("\"\n");


    //MAIN STARTS HERE !!!
    fp->write("\n");
    m_state.indent(fp);
    fp->write("int main()\n");
    
    m_state.indent(fp);
    fp->write("{\n");

    m_state.m_currentIndentLevel++;

    m_state.indent(fp);
    fp->write("enum { SIZE = ");
    fp->write_decimal(BITSPERATOM);
    fp->write(" };\n");

    m_state.indent(fp);
    fp->write("typedef MFM::ParamConfig<SIZE> OurParamConfig;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::P3Atom<OurParamConfig> OurAtom;\n");

    m_state.indent(fp);
    fp->write("typedef MFM::CoreConfig<OurAtom, OurParamConfig> OurCoreConfig;\n");

    //declare an instance of This class
    Symbol * csym = m_state.m_programDefST.getSymbolPtr(m_compileThisId);
    UTI cuti = csym->getUlamTypeIdx();

    m_state.indent(fp);
    fp->write("typedef ");
    fp->write("MFM::");
    fp->write(m_state.getUlamTypeByIndex(cuti)->getUlamTypeMangledName(&m_state).c_str());
    fp->write("<OurCoreConfig> OurFoo;\n");

    m_state.indent(fp);
    fp->write("OurFoo& foo = OurFoo::THE_INSTANCE;\n");
    
    m_state.indent(fp);
    fp->write("foo.SetType(23); //This is actually done by code code in a complicated way\n");

    m_state.indent(fp);
    fp->write("OurAtom fooAtom = foo.GetDefaultAtom();\n");

    m_state.indent(fp);
    fp->write("MFM::Ui_Ut_102323Int rtn;\n");

    m_state.indent(fp);
    fp->write("rtn = OurFoo::Uf_4test(fooAtom);\n");  //hardcoded mangled test name

#if 0
    // output for t3200..
    m_state.indent(fp);
    fp->write("printf(\"Bar1 toInt = %d\\n\", OurFoo::Ut_Um_4bar1::Uf_5toInt(fooAtom).read());\n");
    m_state.indent(fp);
    fp->write("printf(\"Bar2 toInt = %d\\n\", OurFoo::Ut_Um_4bar2::Uf_5toInt(fooAtom).read());\n");
#endif

    m_state.indent(fp);
    //fp->write("return 0;\n");
    fp->write("return rtn.read();\n");         // useful to return result of test
	
    m_state.m_currentIndentLevel--;

    m_state.indent(fp);
    fp->write("}\n");
    delete fp;
  }



} //end MFM
