## -*- mode:ulam -*-
#=t3653_test_compiler_elementandquark_arrayofquarkcaarrays_ish
#!
Exit status: 11
Ue_IshD { typedef QSwapLine(4) OurSwapLine;  Int(32) test() {  11u cast return } }
Uq_QSwapLine(Unary(5) itagBits) : QID(myTagBits) { :< constant Unsigned(32) cQID_TAG_BITS = myTagBits;  Bits(UNKNOWN) mArray[UNKNOWN](notready); > Int(UNKNOWN) mPhase(unknown);  <NOMAIN> }
Uq_QID(Unary(5) myTagBits) { constant Unsigned(32) cQID_TAG_BITS = myTagBits;  Bits(UNKNOWN) mArray[UNKNOWN](notready);  <NOMAIN> }
##
## informed by Dave ish 1/26/2016, (order matters)
##
#:QW.ulam
  ulam 2;
quark QW {
  Int(8) m;
  Int aref(Int i) { return m; }
  Void aset(Int i, Int v) { m = (Int(8)) v; }
}

#>IshE.ulam
  ulam 2;
use System;
element IshE {
  Bool sp;
  QW mA[2];
  Int get(Int x, Int y) {
    QW & r = mA[x];
    return r[y];
  }
  Void set(Int x, Int y, Int v) {
    QW & r = mA[x];
    r[y] = v;
  }
  Int test() {
    System s;
    set(1,0,4);
    s.print(get(1,0));
    s.assert((get(1,0) - 4) == 0);
    set(0,0,3); //clobbers previous 'set'
    s.print(get(0,0));
    s.assert((get(0,0) - 3) == 0);
    s.assert((get(1,0) - 4) == 0);
    return get(1,0) - 4; // should be 0
  }
}
use QW;

#:System.ulam
ulam 1;
quark System {
Void print(Unsigned arg) native;
Void print(Int arg) native;
Void print(Int(4) arg) native;
Void print(Int(3) arg) native;
Void print(Unary(3) arg) native;
Void print(Bool(3) arg) native;
Void assert(Bool b) native;
}
#.
