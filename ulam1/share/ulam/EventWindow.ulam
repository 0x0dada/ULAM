ulam 1;
use C2D;
quark EventWindow {
  typedef Unsigned(6) SiteNum;
  typedef Unsigned(3) Symmetry;

  SiteNum size() native;

  Atom aref(SiteNum index) native;
  Atom aref(Int index) { return aref((SiteNum) index); }
  //  Atom aref(C2D coord) { return aref(getSiteNumber(coord)); }

  Void aset(SiteNum index, Atom val) native;
  Void aset(Int index, Atom val) { aset((SiteNum) index, val); }
  //  Void aset(C2D coord, Atom val) { aset(getSiteNumber(coord), val); }

  Bool isLegal(SiteNum index) { return index < size(); }
  Bool isLegal(Int index) { return index >= 0 && isLegal((SiteNum) index); }
  Bool isLegal(C2D coord) { return isLegal(getSiteNumber(coord)); }

  Bool isLive(SiteNum index) native;
  Bool isLive(Int index) { return isLegal(index) && isLive((SiteNum) index); }
  Bool isLive(C2D coord) { return isLegal(coord) && isLive(getSiteNumber(coord)); }

  Bool swap(SiteNum index1, SiteNum index2)  native;
  Bool swap(Int index1, Int index2) { return swap((SiteNum) index1, (SiteNum) index2); }
  Bool swap(C2D coord1, C2D coord2) { return swap(getSiteNumber(coord1), getSiteNumber(coord2)); }

  C2D getCoord(SiteNum siteNum) native;

  /**
     Map directCoord through the current symmetry and return the
     corresponding position.
   */
  C2D mapSym(C2D directCoord) native;
  C2D mapSyM(C2D directCoord) {
    C2D ret;
    ret.x = -directCoord.x;
    ret.y = directCoord.y;
    return ret;
  }

  /** Get the SiteNum corresponding to \c coord, if it exists, else
      return EventWindow.size() (which is an illegal SiteNum, and will
      cause event window array accesses to fail if used).
  */
  SiteNum getSiteNumber(C2D coord) native;

  Symmetry changeSymmetry(Symmetry newSym) native;

  Void diffuse() native;
}
