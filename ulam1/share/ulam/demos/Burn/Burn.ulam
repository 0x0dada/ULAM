ulam 1;
use EventWindow;
use WindowServices;
use Empty;
use ColorUtils;
use Random;
use XTimer;
use Trigger;

/**
   'Burnable' active media demo.  Render a bunch of these guys with
   Atom #1 and then create a Spark atom (below) next to them, while
   the grid is running.  Try various Burn shapes and arrangements.
   Can you make a fire that never goes out?

   \symbol Bu
   \symmetries normal
   \color #e44
   \author Dave Ackley
   \license public-domain
 */
element Burn : Trigger {
  EventWindow ew;
  Random random;

  typedef EventWindow.SiteNum SiteNum;
  typedef ColorUtils.ARGB ARGB;
  typedef ColorUtils.Channel Channel;
  typedef Unsigned(6) Counter;

  Counter mCount;

  Void behave() {

    // Am I recovering?
    if (mCount < mCount.maxof) {
      ++mCount;   // Yes
      return;
    }

    // I am recovered..
    doArm();

    // If no spark from me or someone near me..
    if (!isPulled()) return;  // I'm done

    // Fire fire fire!  Try to pull every nearby trigger!
    WindowServices ws;
    ws.reset(1,2);
    for (Int slot = ws.next(); slot >= 0; slot = ws.next()) {
      SiteNum s = (SiteNum) slot;
      Atom other = ew[s];
      if (other as Trigger) {
        other.doPull();
      }
      ew[s] = other;
    }

    // Our work is done.  We're tired.
    doSafe();
    mCount = mCount.minof;
  }

  ARGB getColor(Unsigned selector) {
    ColorUtils cu;
    ARGB ret = cu.color(0xffffff00U);
    if (selector == 1u) {
      Unsigned incr = Unsigned(8).maxof/(Unsigned) mCount.maxof;
      ret[3] = (Channel) (incr*mCount);
      ret[2] = (Channel) (incr*(mCount.maxof-mCount));
    } else if (selector == 2u) {
    }
    return ret;
  }

}


/**
   An Burn atom trigger.  A Spark only survives for one event, during
   which it decays into a Burn atom in the mCount of firing.

   \symbol Sp
   \color #00f
 */
element Spark {
  EventWindow ew;
  Void behave() {
    Burn atom;
    atom.mCount = atom.mCount.maxof;
    atom.doSafe();
    atom.doArm();
    atom.doPull();
    ew[0] = (Atom) atom;
  }
}
