package ULAMScanner;
use strict;
use warnings;
use diagnostics;
use Carp;

our $VERSION = 1.002;

sub new {
    my $class = shift;
    my $self = {
    };
    bless $self, $class;
    return $self;
}

sub analyzeDoc {
    my ($self, $name, $doc) = @_;
    if ($doc =~ m!\s*(/[*][*]\s*)?(.*?)\s*([*]/)?\s*$!s) {
        $doc = $2;
    } elsif ($doc eq "NONE") {
        $doc = "";
    } else {
        print STDERR "Unrecognized doc '$doc', treated as empty.\n";
        $doc = "";
    }

    my @pieces = split(/\\(?=[A-Za-z][A-Za-z])/,$doc); # uneaten lookahead!
    my $text = shift @pieces;
    $text = "" unless defined $text;

    my %keys;
    my ($brief, $detail) = ($text,"");
    if ($brief =~ /^([^.]+[.])\s*(.*?)\s*$/s) {
        $brief = $1;
        $detail = $2;
    }
    $brief = "$name (no summary provided)" if $brief eq "";
    $detail = "(no details provided)" if $detail eq "";
    $keys{'brief'} = $brief;
    $keys{'detail'} = $detail;
    while (my $key = shift @pieces) {
        my $val = "";
        if ($key =~ /^([^ ]+)\s+(.*?)\s*$/) {
            $key = $1;
            $val = $2;
        }
        if (defined $keys{$key}) {
            $keys{$key} .= " ";
        } else {
            $keys{$key} = "";
        }
        $keys{$key} .= $val;
    }
    $keys{'name'} = $name;
    return %keys;
}

sub standardizeWhitespace {
    my ($self, $val) = @_;
    # Split on w/s runs including at least two newlines
    my @pieces = split(/\s*\n\s*\n\s*/, $val);
    # Convert w/s runs within each piece to single space
    @pieces = map { $_ =~ s/\s+/ /g; $_ } @pieces;
    # Conjoin pieces with single blank lines between them
    return join("\n\n",@pieces);
}

sub normalizeKeys {
    my ($self, %keys) = @_;

    if (defined $keys{'colors'}) {
        print STDERR "'\\colors' key not accepted, ignored.  Use '\\color'\n";
        delete $keys{'colors'};
    }

    ###
    # 'color' key analysis

    my $w = "0xFFFFFFFF";
    if (!defined $keys{'color'}) {
        $keys{'color'} = $w;
    } else {
        my $c = $keys{'color'};
        if ($c =~ /^(dynamic|function)$/i) {
            print STDERR "Color keyword '$c' no longer accepted; using white ($w)\n";
            $c = $w;
        } elsif ($c =~ /^(0x|#)([0-9a-fA-F]{8})$/) {
            $c = "0x$2";
        } elsif  ($c =~ /^(0x|#)([0-9a-fA-F]{6})$/) {
            $c = "0xff$2";  # add alpha
        } elsif  ($c =~ /^(0x|#)([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/) {
            $c = "0xff$2$2$3$3$4$4"; # expand 12 bit color
        } else {
            print STDERR "Unrecognized color '$c', replaced with white ($w)\n";
            $c = $w;
        }
        $keys{'color'} = $c;
    }

    ###
    # 'symbol' key analysis

    my $symbol = "";
    if (defined $keys{'symbol'} && $keys{'symbol'} ne "") {
        $symbol = $keys{'symbol'};
    } else {
        $symbol = $keys{'name'};
    }
    if (length($symbol) > 2) {
        substr($symbol,2) = "";
    }
    substr($symbol,0,1) = uc(substr($symbol,0,1));
#    print STDERR "\nSYMV($symbol)\n";
    $keys{'symbol'} = $symbol;

    ###
    # 'version' key analysis
    my $version = "0";
    if (defined $keys{'version'}) {
        $version = $1
            if $keys{'version'} =~ /^([0-9]+)$/;
    }
    if (length($version) > 1) {
        $version =~ s/^0+//;  # eat leading zeros
    }
    if (length($version) > 9) {
        $version = substr($version,-9);  # fuck you
    }
    $keys{'version'} = $version;

    ###
    # 'symmetries' key analysis
    my %symkeys = (
        "0" => 1<<0, "1" => 1<<1, "2" => 1<<2, "3" => 1<<3,
        "4" => 1<<4, "5" => 1<<5, "6" => 1<<6, "7" => 1<<7,
        "all" => 0xff,
        "rotations" => 0x0f,
        "0L" => 1<<0, "90L" => 1<<1, "180L" => 1<<2, "270L" => 1<<3,
        "0R" => 1<<4, "90R" => 1<<5, "180R" => 1<<6, "270R" => 1<<7,
        "normal" => 1<<0,
        "flipx" => 1<<6, "flipy" => 1<<4, "flipxy" => 1<<2,
        );

    my @syms;
    my $symmetries;
    if (defined $keys{'symmetry'}) {
        $symmetries = $keys{'symmetry'};
        delete $keys{'symmetry'};
    }
    if (defined $keys{'symmetries'}) {
        warn "\\symmetries taking precedence over \\symmetry"
            if (defined $symmetries);
        $symmetries = $keys{'symmetries'};
    }
    $symmetries = "0" unless defined $symmetries;
    if ($symmetries =~ /^[0-7]+$/) {
        @syms = split(//,$symmetries);
    } else {
        @syms = split(/[\s,;]+/,$symmetries);
    }
    my $symbits = 0;
    for (my $i = 0; $i < scalar(@syms); ++$i) {
        my $k = $syms[$i];
        my $v = $symkeys{lc($k)};
        if (!defined $v) {
            warn "unknown symmetry '$k' ignored";
        } else {
            $symbits |= $v;
        }
    }
    if ($symbits == 0) {
        $symbits = 1<<0;
    }

    my $final = "";
    my $finalCount = 0;
    for (my $i = 0; $i < 8; ++$i) {
        if ($symbits&(1<<$i)) {
            ++$finalCount;
            $final .= ","
                if $final ne "";
            $final .= $i;
        }
    }
    $keys{'numsymmetries'} = $finalCount;
    $keys{'symmetries'} = $final;

    ###
    # 'author' key analysis
    if (!defined $keys{'author'}) {
        $keys{'author'} = "--none specified--";
    }

    ###
    # 'copyright' key analysis
    if (!defined $keys{'copyright'}) {
        $keys{'copyright'} = "--none specified--";
    }

    ###
    # 'license' key analysis
    if (!defined $keys{'license'}) {
        $keys{'license'} = "--none specified--";
    }

    ###
    # 'placeable' key analysis
    if (!defined $keys{'placeable'}) {
        $keys{'placeable'} = "yes";
    }
    $keys{'placeable'} = lc($keys{'placeable'});
    $keys{'placeable'} = "no" if $keys{'placeable'} =~ /off|false|0/;
    $keys{'placeable'} = "yes" if $keys{'placeable'} =~ /on|true|1/;
    $keys{'placeable'} = "yes" unless $keys{'placeable'} eq "no";

    ###
    # 'diffusability' key analysis
    my $diffusability;
    my $inp = $keys{'diffusability'};
    $inp = $keys{'diffusable'} unless defined $inp;
    if (defined $inp && $inp =~ /^([0-9]+)$/) {
        $diffusability = $1;
        $diffusability = 100 if $diffusability > 100;
    }
    $keys{'diffusability'} = $diffusability;
    delete $keys{'diffusable'};

    return %keys;
}

sub escapeChar {
    my $char = shift;
    return "\\n" if $char eq "\n";
    return "\\\\" if $char eq "\\";
    return "\\a" if $char eq "\a";
    return "\\t" if $char eq "\t";
    return "\\\"" if $char eq "\"";
    return sprintf("\\x%02x",ord($char));
}

sub makeCString {
    my ($self, $string) = @_;
    $string =~ s/(["\\\n]|[^[:print:]])/escapeChar("$1")/ge;
    return '"'.$string.'"';
}

1
